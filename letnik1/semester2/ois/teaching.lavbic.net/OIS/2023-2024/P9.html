<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Poglavje 16 P9 Objektno usmerjena analiza, načrtovanje in modeliranje | Osnove informacijskih sistemov 2023/2024</title>
  <meta name="description" content="Skripta za pomoč pri predmetu Osnove informacijskih sistemov 2023/2024" />
  <meta name="generator" content="bookdown 0.39 and GitBook 2.6.7" />

  <meta property="og:title" content="Poglavje 16 P9 Objektno usmerjena analiza, načrtovanje in modeliranje | Osnove informacijskih sistemov 2023/2024" />
  <meta property="og:type" content="book" />
  
  <meta property="og:description" content="Skripta za pomoč pri predmetu Osnove informacijskih sistemov 2023/2024" />
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Poglavje 16 P9 Objektno usmerjena analiza, načrtovanje in modeliranje | Osnove informacijskih sistemov 2023/2024" />
  
  <meta name="twitter:description" content="Skripta za pomoč pri predmetu Osnove informacijskih sistemov 2023/2024" />
  

<meta name="author" content="izr. prof. dr. Dejan Lavbič" />



  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="P8.html"/>
<link rel="next" href="P10.html"/>
<script src="assets/lib/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.min.js"></script>
<link href="assets/lib/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="assets/lib/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="assets/lib/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="assets/lib/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="assets/lib/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="assets/lib/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="assets/lib/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />








<link href="assets/lib/anchor-sections-1.1.0/anchor-sections.css" rel="stylesheet" />
<link href="assets/lib/anchor-sections-1.1.0/anchor-sections-hash.css" rel="stylesheet" />
<script src="assets/lib/anchor-sections-1.1.0/anchor-sections.js"></script>
<script src="assets/lib/kePrint-0.0.1/kePrint.js"></script>
<link href="assets/lib/lightable-0.0.1/lightable.css" rel="stylesheet" />


<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<style type="text/css">
  
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
</style>
<style type="text/css">
/* Used with Pandoc 2.11+ new --citeproc when CSL is used */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>

<link rel="stylesheet" href="assets/style/stil.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="index.html#terminski-plan-izvajanja-predmeta">OIS 2023/2024 terminski plan</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Uvod</a>
<ul>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#splošne-informacije"><i class="fa fa-check"></i>Splošne informacije</a>
<ul>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#predavatelj"><i class="fa fa-check"></i>Predavatelj</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#asistent"><i class="fa fa-check"></i>Asistent</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#terminski-plan-izvajanja-predmeta"><i class="fa fa-check"></i>Terminski plan izvajanja predmeta</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#pravila-igre"><i class="fa fa-check"></i>Pravila igre</a>
<ul>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#predavanja"><i class="fa fa-check"></i>Predavanja</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#vaje"><i class="fa fa-check"></i>Vaje</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#ocenjevanje"><i class="fa fa-check"></i>Ocenjevanje</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#pisni-izpiti"><i class="fa fa-check"></i>Pisni izpiti</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#priporočena-literatura"><i class="fa fa-check"></i>Priporočena literatura</a></li>
</ul></li>
<li class="part"><span><b>I sklop: Poslovni informacijski sistemi in upravljanje informatike</b></span></li>
<li class="chapter" data-level="1" data-path="P1.html"><a href="P1.html"><i class="fa fa-check"></i><b>1</b> <span class="sklop1 oznaka">P1</span> Upravljanje IT</a>
<ul>
<li class="chapter" data-level="1.1" data-path="P1.html"><a href="P1.html#ogrodje-digitalne-preobrazbe"><i class="fa fa-check"></i><b>1.1</b> Ogrodje digitalne preobrazbe</a></li>
<li class="chapter" data-level="1.2" data-path="P1.html"><a href="P1.html#uvod-1"><i class="fa fa-check"></i><b>1.2</b> Uvod</a></li>
<li class="chapter" data-level="1.3" data-path="P1.html"><a href="P1.html#upravljanje-it-in-vloga-informatike"><i class="fa fa-check"></i><b>1.3</b> Upravljanje IT in vloga informatike</a>
<ul>
<li class="chapter" data-level="1.3.1" data-path="P1.html"><a href="P1.html#vloga-vodstva-pri-upravljanju-it"><i class="fa fa-check"></i><b>1.3.1</b> Vloga vodstva pri upravljanju IT</a></li>
<li class="chapter" data-level="1.3.2" data-path="P1.html"><a href="P1.html#ključna-vprašanja-o-it"><i class="fa fa-check"></i><b>1.3.2</b> Ključna vprašanja o IT</a></li>
</ul></li>
<li class="chapter" data-level="1.4" data-path="P1.html"><a href="P1.html#ogrodje-za-upravljanje-it"><i class="fa fa-check"></i><b>1.4</b> Ogrodje za upravljanje IT</a>
<ul>
<li class="chapter" data-level="1.4.1" data-path="P1.html"><a href="P1.html#ključne-odločitve"><i class="fa fa-check"></i><b>1.4.1</b> Ključne odločitve</a></li>
<li class="chapter" data-level="1.4.2" data-path="P1.html"><a href="P1.html#ključni-odločevalci"><i class="fa fa-check"></i><b>1.4.2</b> Ključni odločevalci</a></li>
<li class="chapter" data-level="1.4.3" data-path="P1.html"><a href="P1.html#strukture-in-procesi-odločanja"><i class="fa fa-check"></i><b>1.4.3</b> Strukture in procesi odločanja</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="2" data-path="P1-V1.html"><a href="P1-V1.html"><i class="fa fa-check"></i><b>2</b> <span class="sklop1 oznaka">P1</span> → <span class="sklop3 oznaka">V1</span> Obvladovanje verzij</a>
<ul>
<li class="chapter" data-level="2.1" data-path="P1-V1.html"><a href="P1-V1.html#zgodovina-vcs"><i class="fa fa-check"></i><b>2.1</b> Zgodovina VCS</a></li>
<li class="chapter" data-level="2.2" data-path="P1-V1.html"><a href="P1-V1.html#osnovne-operacije-vcs"><i class="fa fa-check"></i><b>2.2</b> Osnovne operacije VCS</a>
<ul>
<li class="chapter" data-level="2.2.1" data-path="P1-V1.html"><a href="P1-V1.html#VCS-create"><i class="fa fa-check"></i><b>2.2.1</b> Create</a></li>
<li class="chapter" data-level="2.2.2" data-path="P1-V1.html"><a href="P1-V1.html#VCS-checkout"><i class="fa fa-check"></i><b>2.2.2</b> Checkout</a></li>
<li class="chapter" data-level="2.2.3" data-path="P1-V1.html"><a href="P1-V1.html#VCS-commit"><i class="fa fa-check"></i><b>2.2.3</b> Commit</a></li>
<li class="chapter" data-level="2.2.4" data-path="P1-V1.html"><a href="P1-V1.html#VCS-update"><i class="fa fa-check"></i><b>2.2.4</b> Update</a></li>
<li class="chapter" data-level="2.2.5" data-path="P1-V1.html"><a href="P1-V1.html#VCS-add"><i class="fa fa-check"></i><b>2.2.5</b> Add</a></li>
<li class="chapter" data-level="2.2.6" data-path="P1-V1.html"><a href="P1-V1.html#VCS-edit"><i class="fa fa-check"></i><b>2.2.6</b> Edit</a></li>
<li class="chapter" data-level="2.2.7" data-path="P1-V1.html"><a href="P1-V1.html#VCS-delete"><i class="fa fa-check"></i><b>2.2.7</b> Delete</a></li>
<li class="chapter" data-level="2.2.8" data-path="P1-V1.html"><a href="P1-V1.html#VCS-rename"><i class="fa fa-check"></i><b>2.2.8</b> Rename</a></li>
<li class="chapter" data-level="2.2.9" data-path="P1-V1.html"><a href="P1-V1.html#VCS-move"><i class="fa fa-check"></i><b>2.2.9</b> Move</a></li>
<li class="chapter" data-level="2.2.10" data-path="P1-V1.html"><a href="P1-V1.html#VCS-status"><i class="fa fa-check"></i><b>2.2.10</b> Status</a></li>
<li class="chapter" data-level="2.2.11" data-path="P1-V1.html"><a href="P1-V1.html#VCS-diff"><i class="fa fa-check"></i><b>2.2.11</b> Diff</a></li>
<li class="chapter" data-level="2.2.12" data-path="P1-V1.html"><a href="P1-V1.html#VCS-revert"><i class="fa fa-check"></i><b>2.2.12</b> Revert</a></li>
<li class="chapter" data-level="2.2.13" data-path="P1-V1.html"><a href="P1-V1.html#VCS-log"><i class="fa fa-check"></i><b>2.2.13</b> Log</a></li>
<li class="chapter" data-level="2.2.14" data-path="P1-V1.html"><a href="P1-V1.html#VCS-tag"><i class="fa fa-check"></i><b>2.2.14</b> Tag</a></li>
<li class="chapter" data-level="2.2.15" data-path="P1-V1.html"><a href="P1-V1.html#VCS-branch"><i class="fa fa-check"></i><b>2.2.15</b> Branch</a></li>
<li class="chapter" data-level="2.2.16" data-path="P1-V1.html"><a href="P1-V1.html#VCS-merge"><i class="fa fa-check"></i><b>2.2.16</b> Merge</a></li>
<li class="chapter" data-level="2.2.17" data-path="P1-V1.html"><a href="P1-V1.html#VCS-resolve"><i class="fa fa-check"></i><b>2.2.17</b> Resolve</a></li>
<li class="chapter" data-level="2.2.18" data-path="P1-V1.html"><a href="P1-V1.html#VCS-lock"><i class="fa fa-check"></i><b>2.2.18</b> Lock</a></li>
</ul></li>
<li class="chapter" data-level="2.3" data-path="P1-V1.html"><a href="P1-V1.html#posebnosti-dvcs"><i class="fa fa-check"></i><b>2.3</b> Posebnosti DVCS</a>
<ul>
<li class="chapter" data-level="2.3.1" data-path="P1-V1.html"><a href="P1-V1.html#clone"><i class="fa fa-check"></i><b>2.3.1</b> Clone</a></li>
<li class="chapter" data-level="2.3.2" data-path="P1-V1.html"><a href="P1-V1.html#primerjava-cvcs-in-dvcs"><i class="fa fa-check"></i><b>2.3.2</b> Primerjava CVCS in DVCS</a></li>
<li class="chapter" data-level="2.3.3" data-path="P1-V1.html"><a href="P1-V1.html#push"><i class="fa fa-check"></i><b>2.3.3</b> Push</a></li>
<li class="chapter" data-level="2.3.4" data-path="P1-V1.html"><a href="P1-V1.html#pull"><i class="fa fa-check"></i><b>2.3.4</b> Pull</a></li>
</ul></li>
<li class="chapter" data-level="2.4" data-path="P1-V1.html"><a href="P1-V1.html#dobre-prakse-uporabe-git"><i class="fa fa-check"></i><b>2.4</b> Dobre prakse uporabe Git</a>
<ul>
<li class="chapter" data-level="2.4.1" data-path="P1-V1.html"><a href="P1-V1.html#osrednji-repozitorij-in-sodelovanje-med-skupinami"><i class="fa fa-check"></i><b>2.4.1</b> Osrednji repozitorij in sodelovanje med skupinami</a></li>
<li class="chapter" data-level="2.4.2" data-path="P1-V1.html"><a href="P1-V1.html#razdelitev-po-vejah-razvoja"><i class="fa fa-check"></i><b>2.4.2</b> Razdelitev po vejah razvoja</a></li>
<li class="chapter" data-level="2.4.3" data-path="P1-V1.html"><a href="P1-V1.html#sporočila-uveljavitev"><i class="fa fa-check"></i><b>2.4.3</b> Sporočila uveljavitev</a></li>
</ul></li>
<li class="chapter" data-level="2.5" data-path="P1-V1.html"><a href="P1-V1.html#dodatno-gradivo"><i class="fa fa-check"></i><b>2.5</b> Dodatno gradivo</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="P2.html"><a href="P2.html"><i class="fa fa-check"></i><b>3</b> <span class="sklop1 oznaka">P2</span> Delovni model, arhitektura podjetja in vrednotenje naložb</a>
<ul>
<li class="chapter" data-level="3.1" data-path="P2.html"><a href="P2.html#delovni-model-in-zrelost-arhitekture-podjetja"><i class="fa fa-check"></i><b>3.1</b> Delovni model in zrelost arhitekture podjetja</a>
<ul>
<li class="chapter" data-level="3.1.1" data-path="P2.html"><a href="P2.html#delovni-model"><i class="fa fa-check"></i><b>3.1.1</b> Delovni model</a></li>
<li class="chapter" data-level="3.1.2" data-path="P2.html"><a href="P2.html#arhitektura-podjetja"><i class="fa fa-check"></i><b>3.1.2</b> Arhitektura podjetja</a></li>
<li class="chapter" data-level="3.1.3" data-path="P2.html"><a href="P2.html#posledice-zrelosti-arhitekture-podjetja"><i class="fa fa-check"></i><b>3.1.3</b> Posledice zrelosti arhitekture podjetja</a></li>
</ul></li>
<li class="chapter" data-level="3.2" data-path="P2.html"><a href="P2.html#vrednotenje-naložb"><i class="fa fa-check"></i><b>3.2</b> Vrednotenje naložb</a>
<ul>
<li class="chapter" data-level="3.2.1" data-path="P2.html"><a href="P2.html#parametrični-pristop-od-zgoraj-navzdol"><i class="fa fa-check"></i><b>3.2.1</b> Parametrični pristop od zgoraj navzdol</a></li>
<li class="chapter" data-level="3.2.2" data-path="P2.html"><a href="P2.html#pristop-od-spodaj-navzgor"><i class="fa fa-check"></i><b>3.2.2</b> Pristop od spodaj navzgor</a></li>
<li class="chapter" data-level="3.2.3" data-path="P2.html"><a href="P2.html#ocena-proračuna"><i class="fa fa-check"></i><b>3.2.3</b> Ocena proračuna</a></li>
<li class="chapter" data-level="3.2.4" data-path="P2.html"><a href="P2.html#ocena-proracuna-s-pristopm-navzdol"><i class="fa fa-check"></i><b>3.2.4</b> Primer ocene proračuna s pristopom od zgoraj navzdol</a></li>
<li class="chapter" data-level="3.2.5" data-path="P2.html"><a href="P2.html#UCP"><i class="fa fa-check"></i><b>3.2.5</b> Formalna metoda za ocenjevanje stroškov programske opreme</a></li>
</ul></li>
<li class="chapter" data-level="3.3" data-path="P2.html"><a href="P2.html#nematerialne-koristi"><i class="fa fa-check"></i><b>3.3</b> Nematerialne koristi</a>
<ul>
<li class="chapter" data-level="3.3.1" data-path="P2.html"><a href="P2.html#zmogljivost-informacijske-tehnologije"><i class="fa fa-check"></i><b>3.3.1</b> Zmogljivost informacijske tehnologije</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="4" data-path="P2-V3.html"><a href="P2-V3.html"><i class="fa fa-check"></i><b>4</b> <span class="sklop1 oznaka">P2</span> → <span class="sklop3 oznaka">V3</span> Uvod v HTML in CSS</a>
<ul>
<li class="chapter" data-level="4.1" data-path="P2-V3.html"><a href="P2-V3.html#html"><i class="fa fa-check"></i><b>4.1</b> HTML</a>
<ul>
<li class="chapter" data-level="4.1.1" data-path="P2-V3.html"><a href="P2-V3.html#gradniki"><i class="fa fa-check"></i><b>4.1.1</b> Gradniki</a></li>
<li class="chapter" data-level="4.1.2" data-path="P2-V3.html"><a href="P2-V3.html#zaključek"><i class="fa fa-check"></i><b>4.1.2</b> Zaključek</a></li>
</ul></li>
<li class="chapter" data-level="4.2" data-path="P2-V3.html"><a href="P2-V3.html#CSS"><i class="fa fa-check"></i><b>4.2</b> CSS</a>
<ul>
<li class="chapter" data-level="4.2.1" data-path="P2-V3.html"><a href="P2-V3.html#gradniki-1"><i class="fa fa-check"></i><b>4.2.1</b> Gradniki</a></li>
<li class="chapter" data-level="4.2.2" data-path="P2-V3.html"><a href="P2-V3.html#zaključek-1"><i class="fa fa-check"></i><b>4.2.2</b> Zaključek</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="5" data-path="P3.html"><a href="P3.html"><i class="fa fa-check"></i><b>5</b> <span class="sklop1 oznaka">P3</span> Tveganja, IT naložbeni portfelj in povračilo sredstev</a>
<ul>
<li class="chapter" data-level="5.1" data-path="P3.html"><a href="P3.html#tveganja-pri-projektih-it"><i class="fa fa-check"></i><b>5.1</b> Tveganja pri projektih IT</a>
<ul>
<li class="chapter" data-level="5.1.1" data-path="P3.html"><a href="P3.html#upoštevanje-tveganja-pri-vrednotenju-naložb-v-it"><i class="fa fa-check"></i><b>5.1.1</b> Upoštevanje tveganja pri vrednotenju naložb v IT</a></li>
<li class="chapter" data-level="5.1.2" data-path="P3.html"><a href="P3.html#kako-podjetja-upoštevajo-tveganja"><i class="fa fa-check"></i><b>5.1.2</b> Kako podjetja upoštevajo tveganja?</a></li>
</ul></li>
<li class="chapter" data-level="5.2" data-path="P3.html"><a href="P3.html#pristop-z-opcijami-pri-naložbah-v-it"><i class="fa fa-check"></i><b>5.2</b> Pristop z opcijami pri naložbah v IT</a>
<ul>
<li class="chapter" data-level="5.2.1" data-path="P3.html"><a href="P3.html#primer-starbuck"><i class="fa fa-check"></i><b>5.2.1</b> Primer Starbuck</a></li>
<li class="chapter" data-level="5.2.2" data-path="P3.html"><a href="P3.html#primer-opcije"><i class="fa fa-check"></i><b>5.2.2</b> Primer implementacije sistema</a></li>
</ul></li>
<li class="chapter" data-level="5.3" data-path="P3.html"><a href="P3.html#ogrodje-za-vrednotenje-naložb-v-it"><i class="fa fa-check"></i><b>5.3</b> Ogrodje za vrednotenje naložb v IT</a>
<ul>
<li class="chapter" data-level="5.3.1" data-path="P3.html"><a href="P3.html#pasti-prekinitve"><i class="fa fa-check"></i><b>5.3.1</b> Pasti prekinitve</a></li>
<li class="chapter" data-level="5.3.2" data-path="P3.html"><a href="P3.html#pasti-odložitve"><i class="fa fa-check"></i><b>5.3.2</b> Pasti odložitve</a></li>
</ul></li>
<li class="chapter" data-level="5.4" data-path="P3.html"><a href="P3.html#it-naložbeni-portfelj"><i class="fa fa-check"></i><b>5.4</b> IT naložbeni portfelj</a>
<ul>
<li class="chapter" data-level="5.4.1" data-path="P3.html"><a href="P3.html#upravljanje-portfelja-it"><i class="fa fa-check"></i><b>5.4.1</b> Upravljanje portfelja IT</a></li>
<li class="chapter" data-level="5.4.2" data-path="P3.html"><a href="P3.html#lastnosti-različnih-skupin-sredstev-it"><i class="fa fa-check"></i><b>5.4.2</b> Lastnosti različnih skupin sredstev IT</a></li>
<li class="chapter" data-level="5.4.3" data-path="P3.html"><a href="P3.html#strateška-usmeritev-in-upravljanje-portfelja"><i class="fa fa-check"></i><b>5.4.3</b> Strateška usmeritev in upravljanje portfelja</a></li>
<li class="chapter" data-level="5.4.4" data-path="P3.html"><a href="P3.html#proces-upravljanja-portfelja-it"><i class="fa fa-check"></i><b>5.4.4</b> Proces upravljanja portfelja IT</a></li>
</ul></li>
<li class="chapter" data-level="5.5" data-path="P3.html"><a href="P3.html#povračilo-sredstev-za-it"><i class="fa fa-check"></i><b>5.5</b> Povračilo sredstev za IT</a>
<ul>
<li class="chapter" data-level="5.5.1" data-path="P3.html"><a href="P3.html#razumevanje-izziva-povračila-sredstev-za-it"><i class="fa fa-check"></i><b>5.5.1</b> Razumevanje izziva povračila sredstev za IT</a></li>
<li class="chapter" data-level="5.5.2" data-path="P3.html"><a href="P3.html#različni-pristopi-povračila-sredstev-za-it"><i class="fa fa-check"></i><b>5.5.2</b> Različni pristopi povračila sredstev za IT</a></li>
<li class="chapter" data-level="5.5.3" data-path="P3.html"><a href="P3.html#posledice-povračil-sredstev-za-it"><i class="fa fa-check"></i><b>5.5.3</b> Posledice povračil sredstev za IT</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="6" data-path="P3-V3.html"><a href="P3-V3.html"><i class="fa fa-check"></i><b>6</b> <span class="sklop1 oznaka">P3</span> → <span class="sklop3 oznaka">V3</span> JavaScript na strani odjemalca</a>
<ul>
<li class="chapter" data-level="6.1" data-path="P3-V3.html"><a href="P3-V3.html#JavaScript"><i class="fa fa-check"></i><b>6.1</b> JavaScript</a>
<ul>
<li class="chapter" data-level="6.1.1" data-path="P3-V3.html"><a href="P3-V3.html#gradniki-2"><i class="fa fa-check"></i><b>6.1.1</b> Gradniki</a></li>
<li class="chapter" data-level="6.1.2" data-path="P3-V3.html"><a href="P3-V3.html#zaključek-2"><i class="fa fa-check"></i><b>6.1.2</b> Zaključek</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="7" data-path="P4.html"><a href="P4.html"><i class="fa fa-check"></i><b>7</b> <span class="sklop1 oznaka">P4</span> Upravljanje sprememb, IS, podatek, informacija, znanje</a>
<ul>
<li class="chapter" data-level="7.1" data-path="P4.html"><a href="P4.html#upravljanje-sprememb"><i class="fa fa-check"></i><b>7.1</b> Upravljanje sprememb</a>
<ul>
<li class="chapter" data-level="7.1.1" data-path="P4.html"><a href="P4.html#razumevanje-odpora-uporabnikov"><i class="fa fa-check"></i><b>7.1.1</b> Razumevanje odpora uporabnikov</a></li>
<li class="chapter" data-level="7.1.2" data-path="P4.html"><a href="P4.html#odpor-uporabnikov-do-sprememb-perspektiva-pristranskosti"><i class="fa fa-check"></i><b>7.1.2</b> Odpor uporabnikov do sprememb: perspektiva pristranskosti</a></li>
<li class="chapter" data-level="7.1.3" data-path="P4.html"><a href="P4.html#model-prilagajanja-uporabniku"><i class="fa fa-check"></i><b>7.1.3</b> Model prilagajanja uporabniku</a></li>
<li class="chapter" data-level="7.1.4" data-path="P4.html"><a href="P4.html#različni-modeli-sprejetosti-uporabnikov"><i class="fa fa-check"></i><b>7.1.4</b> Različni modeli sprejetosti uporabnikov</a></li>
<li class="chapter" data-level="7.1.5" data-path="P4.html"><a href="P4.html#ključni-vzvodi-pri-uvajanju-informacijskega-sistema"><i class="fa fa-check"></i><b>7.1.5</b> Ključni vzvodi pri uvajanju informacijskega sistema</a></li>
<li class="chapter" data-level="7.1.6" data-path="P4.html"><a href="P4.html#kako-učinkovito-uvesti-spremembe-kritični-dejavniki-uspeha"><i class="fa fa-check"></i><b>7.1.6</b> Kako učinkovito uvesti spremembe: kritični dejavniki uspeha</a></li>
<li class="chapter" data-level="7.1.7" data-path="P4.html"><a href="P4.html#primerjava-evolucijske-in-revolucionarne-spremembe"><i class="fa fa-check"></i><b>7.1.7</b> Primerjava evolucijske in revolucionarne spremembe</a></li>
<li class="chapter" data-level="7.1.8" data-path="P4.html"><a href="P4.html#projektno-vodenje-v-primerjavi-z-učnim-pristopom"><i class="fa fa-check"></i><b>7.1.8</b> Projektno vodenje v primerjavi z učnim pristopom</a></li>
</ul></li>
<li class="chapter" data-level="7.2" data-path="P4.html"><a href="P4.html#sistem"><i class="fa fa-check"></i><b>7.2</b> Sistem</a>
<ul>
<li class="chapter" data-level="7.2.1" data-path="P4.html"><a href="P4.html#opredelitve-osnovnih-pojmov"><i class="fa fa-check"></i><b>7.2.1</b> Opredelitve osnovnih pojmov</a></li>
</ul></li>
<li class="chapter" data-level="7.3" data-path="P4.html"><a href="P4.html#podatek-informacija-in-znanje"><i class="fa fa-check"></i><b>7.3</b> Podatek, informacija in znanje</a>
<ul>
<li class="chapter" data-level="7.3.1" data-path="P4.html"><a href="P4.html#podatek-in-informacija"><i class="fa fa-check"></i><b>7.3.1</b> Podatek in informacija</a></li>
<li class="chapter" data-level="7.3.2" data-path="P4.html"><a href="P4.html#značilnosti-informacij"><i class="fa fa-check"></i><b>7.3.2</b> Značilnosti informacij</a></li>
<li class="chapter" data-level="7.3.3" data-path="P4.html"><a href="P4.html#raziskava-o-kakovosti-informacij"><i class="fa fa-check"></i><b>7.3.3</b> Raziskava o kakovosti informacij</a></li>
<li class="chapter" data-level="7.3.4" data-path="P4.html"><a href="P4.html#znanje"><i class="fa fa-check"></i><b>7.3.4</b> Znanje</a></li>
<li class="chapter" data-level="7.3.5" data-path="P4.html"><a href="P4.html#povezanost-podatka-informacije-in-znanja"><i class="fa fa-check"></i><b>7.3.5</b> Povezanost podatka, informacije in znanja</a></li>
<li class="chapter" data-level="7.3.6" data-path="P4.html"><a href="P4.html#primeri-interpretacij-informacij"><i class="fa fa-check"></i><b>7.3.6</b> Primeri interpretacij informacij</a></li>
<li class="chapter" data-level="7.3.7" data-path="P4.html"><a href="P4.html#znanje-vs.-védenje"><i class="fa fa-check"></i><b>7.3.7</b> Znanje vs. védenje</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="8" data-path="P4-V4.html"><a href="P4-V4.html"><i class="fa fa-check"></i><b>8</b> <span class="sklop1 oznaka">P4</span> → <span class="sklop3 oznaka">V4</span> Odjemalec/strežnik in Node.js</a>
<ul>
<li class="chapter" data-level="8.1" data-path="P4-V4.html"><a href="P4-V4.html#razvoj-enostavnega-spletnega-strežnika"><i class="fa fa-check"></i><b>8.1</b> Razvoj enostavnega spletnega strežnika</a>
<ul>
<li class="chapter" data-level="8.1.1" data-path="P4-V4.html"><a href="P4-V4.html#hello-world"><i class="fa fa-check"></i><b>8.1.1</b> Hello World</a></li>
</ul></li>
<li class="chapter" data-level="8.2" data-path="P4-V4.html"><a href="P4-V4.html#spremenljivke-na-strežniku"><i class="fa fa-check"></i><b>8.2</b> Spremenljivke na strežniku</a></li>
<li class="chapter" data-level="8.3" data-path="P4-V4.html"><a href="P4-V4.html#strežnik-statičnih-spletnih-strani"><i class="fa fa-check"></i><b>8.3</b> Strežnik statičnih spletnih strani</a>
<ul>
<li class="chapter" data-level="8.3.1" data-path="P4-V4.html"><a href="P4-V4.html#knjižnice-ki-jih-bo-naš-projekt-uporabljal"><i class="fa fa-check"></i><b>8.3.1</b> Knjižnice, ki jih bo naš projekt uporabljal</a></li>
<li class="chapter" data-level="8.3.2" data-path="P4-V4.html"><a href="P4-V4.html#uvoz-statičnih-datotek"><i class="fa fa-check"></i><b>8.3.2</b> Uvoz statičnih datotek</a></li>
<li class="chapter" data-level="8.3.3" data-path="P4-V4.html"><a href="P4-V4.html#začnemo-s-pisanjem-kode-na-strežniku"><i class="fa fa-check"></i><b>8.3.3</b> Začnemo s pisanjem kode na strežniku</a></li>
<li class="chapter" data-level="8.3.4" data-path="P4-V4.html"><a href="P4-V4.html#pripravimo-objekt-strežnika-in-ga-osnovno-nastavimo"><i class="fa fa-check"></i><b>8.3.4</b> Pripravimo objekt strežnika in ga osnovno nastavimo</a></li>
<li class="chapter" data-level="8.3.5" data-path="P4-V4.html"><a href="P4-V4.html#strežnik-poženemo"><i class="fa fa-check"></i><b>8.3.5</b> Strežnik poženemo</a></li>
<li class="chapter" data-level="8.3.6" data-path="P4-V4.html"><a href="P4-V4.html#pripravimo-še-manjkajočo-metodo-za-strežbo-statične-vsebine"><i class="fa fa-check"></i><b>8.3.6</b> Pripravimo še manjkajočo metodo za strežbo statične vsebine</a></li>
<li class="chapter" data-level="8.3.7" data-path="P4-V4.html"><a href="P4-V4.html#pripravimo-metodo-za-obvladovanje-napak"><i class="fa fa-check"></i><b>8.3.7</b> Pripravimo metodo za obvladovanje napak</a></li>
<li class="chapter" data-level="8.3.8" data-path="P4-V4.html"><a href="P4-V4.html#pripravimo-tudi-metodo-ki-vrne-datoteko-odjemalcu"><i class="fa fa-check"></i><b>8.3.8</b> Pripravimo tudi metodo, ki vrne datoteko odjemalcu</a></li>
<li class="chapter" data-level="8.3.9" data-path="P4-V4.html"><a href="P4-V4.html#preverimo-delovanje-strežbe-statičnih-strani"><i class="fa fa-check"></i><b>8.3.9</b> Preverimo delovanje strežbe statičnih strani</a></li>
</ul></li>
<li class="chapter" data-level="8.4" data-path="P4-V4.html"><a href="P4-V4.html#strežniku-statičnih-strani-dodamo-predpomnjenje"><i class="fa fa-check"></i><b>8.4</b> Strežniku statičnih strani dodamo predpomnjenje</a></li>
<li class="chapter" data-level="8.5" data-path="P4-V4.html"><a href="P4-V4.html#strežniku-dodamo-dinamične-strani"><i class="fa fa-check"></i><b>8.5</b> Strežniku dodamo dinamične strani</a>
<ul>
<li class="chapter" data-level="8.5.1" data-path="P4-V4.html"><a href="P4-V4.html#popravimo-nastavitev-strežnika"><i class="fa fa-check"></i><b>8.5.1</b> Popravimo nastavitev strežnika</a></li>
<li class="chapter" data-level="8.5.2" data-path="P4-V4.html"><a href="P4-V4.html#implementiramo-metodo-za-obdelavo-sporočila"><i class="fa fa-check"></i><b>8.5.2</b> Implementiramo metodo za obdelavo sporočila</a></li>
<li class="chapter" data-level="8.5.3" data-path="P4-V4.html"><a href="P4-V4.html#implementiramo-zahvalo-uporabniku"><i class="fa fa-check"></i><b>8.5.3</b> Implementiramo zahvalo uporabniku</a></li>
</ul></li>
<li class="chapter" data-level="8.6" data-path="P4-V4.html"><a href="P4-V4.html#testiranje-in-dodatno-gradivo"><i class="fa fa-check"></i><b>8.6</b> Testiranje in dodatno gradivo</a></li>
</ul></li>
<li class="part"><span><b>II sklop: Arhitektura poslovnega informacijskega sistema</b></span></li>
<li class="chapter" data-level="9" data-path="DN.html"><a href="DN.html"><i class="fa fa-check"></i><b>9</b> <span class="sklop3 oznaka">DN</span> Spletna aplikacija FRI izletnik</a>
<ul>
<li class="chapter" data-level="9.1" data-path="DN.html"><a href="DN.html#DN1"><i class="fa fa-check"></i><b>9.1</b> Spletna aplikacija <small>(1. del)</small></a>
<ul>
<li class="chapter" data-level="9.1.1" data-path="DN.html"><a href="DN.html#opis-naloge-in-navodila"><i class="fa fa-check"></i><b>9.1.1</b> Opis naloge in navodila <i class="skrivanje fa-solid fa-circle-exclamation"></i></a></li>
<li class="chapter" data-level="9.1.2" data-path="DN.html"><a href="DN.html#vzpostavitev-repozitorija"><i class="fa fa-check"></i><b>9.1.2</b> Vzpostavitev repozitorija <i class="skrivanje fa-solid fa-circle-exclamation"></i></a></li>
<li class="chapter" data-level="9.1.3" data-path="DN.html"><a href="DN.html#DN11"><i class="fa fa-check"></i><b>9.1.3</b> Skladnja strani in stilska preobrazba <i class="skrivanje fa-solid fa-circle-exclamation"></i></a></li>
<li class="chapter" data-level="9.1.4" data-path="DN.html"><a href="DN.html#DN12"><i class="fa fa-check"></i><b>9.1.4</b> Podpora funkcionalnosti na odjemalcu in strežniku <i class="skrivanje fa-solid fa-circle-exclamation"></i></a></li>
<li class="chapter" data-level="9.1.5" data-path="DN.html"><a href="DN.html#združevanje-sprememb-v-repozitoriju"><i class="fa fa-check"></i><b>9.1.5</b> Združevanje sprememb v repozitoriju <i class="skrivanje fa-solid fa-circle-exclamation"></i></a></li>
</ul></li>
<li class="chapter" data-level="9.2" data-path="DN.html"><a href="DN.html#DN2"><i class="fa fa-check"></i><b>9.2</b> Dopolnitev načrta in implementacija nove funkcionalnosti <small class="skupaj">(2. del)</small></a>
<ul>
<li class="chapter" data-level="9.2.1" data-path="DN.html"><a href="DN.html#DN-navodila"><i class="fa fa-check"></i><b>9.2.1</b> Opis naloge in navodila <i class="skrivanje fa-solid fa-circle-exclamation"></i></a></li>
<li class="chapter" data-level="9.2.2" data-path="DN.html"><a href="DN.html#DN-ideja"><i class="fa fa-check"></i><b>9.2.2</b> Opis osnovne ideje predloga <i class="skrivanje fa-solid fa-circle-exclamation"></i></a></li>
<li class="chapter" data-level="9.2.3" data-path="DN.html"><a href="DN.html#DN-Generiranje-podatkov"><i class="fa fa-check"></i><b>9.2.3</b> Generiranje podatkov <i class="skrivanje fa-solid fa-circle-exclamation"></i></a></li>
<li class="chapter" data-level="9.2.4" data-path="DN.html"><a href="DN.html#DN-nacrt"><i class="fa fa-check"></i><b>9.2.4</b> Načrt informacijske rešitve <i class="skrivanje fa-solid fa-circle-exclamation"></i></a></li>
<li class="chapter" data-level="9.2.5" data-path="DN.html"><a href="DN.html#DN-implementacija"><i class="fa fa-check"></i><b>9.2.5</b> Implementacija funkcionalnosti <i class="skrivanje fa-solid fa-circle-exclamation"></i></a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="10" data-path="P5.html"><a href="P5.html"><i class="fa fa-check"></i><b>10</b> <span class="sklop2 oznaka">P5</span> Metamodel delovnega sistema in arhitektura poslovnega informacijskega sistema</a>
<ul>
<li class="chapter" data-level="10.1" data-path="P5.html"><a href="P5.html#metamodel-delovnega-sistema"><i class="fa fa-check"></i><b>10.1</b> Metamodel delovnega sistema</a>
<ul>
<li class="chapter" data-level="10.1.1" data-path="P5.html"><a href="P5.html#razmerje-med-informacijskim-sistemom-in-delovnim-sistemom"><i class="fa fa-check"></i><b>10.1.1</b> Razmerje med informacijskim sistemom in delovnim sistemom</a></li>
<li class="chapter" data-level="10.1.2" data-path="P5.html"><a href="P5.html#različni-pogledi-na-metamodel-delovnega-sistema"><i class="fa fa-check"></i><b>10.1.2</b> Različni pogledi na metamodel delovnega sistema</a></li>
<li class="chapter" data-level="10.1.3" data-path="P5.html"><a href="P5.html#primeri-metamodelov-delovnega-sistema"><i class="fa fa-check"></i><b>10.1.3</b> Primeri metamodelov delovnega sistema</a></li>
</ul></li>
<li class="chapter" data-level="10.2" data-path="P5.html"><a href="P5.html#arhitektura-poslovnega-informacijskega-sistema"><i class="fa fa-check"></i><b>10.2</b> Arhitektura poslovnega informacijskega sistema</a>
<ul>
<li class="chapter" data-level="10.2.1" data-path="P5.html"><a href="P5.html#uvod-v-poslovne-informacijske-sisteme"><i class="fa fa-check"></i><b>10.2.1</b> Uvod v poslovne informacijske sisteme</a></li>
<li class="chapter" data-level="10.2.2" data-path="P5.html"><a href="P5.html#poklici-povezani-s-poslovnimi-informacijskimi-sistemi"><i class="fa fa-check"></i><b>10.2.2</b> Poklici, povezani s poslovnimi informacijskimi sistemi</a></li>
<li class="chapter" data-level="10.2.3" data-path="P5.html"><a href="P5.html#razumevanje-poslovnih-procesov"><i class="fa fa-check"></i><b>10.2.3</b> Razumevanje poslovnih procesov</a></li>
<li class="chapter" data-level="10.2.4" data-path="P5.html"><a href="P5.html#poslovne-funkcije"><i class="fa fa-check"></i><b>10.2.4</b> Poslovne funkcije</a></li>
<li class="chapter" data-level="10.2.5" data-path="P5.html"><a href="P5.html#primeri-poslovnih-sistemov"><i class="fa fa-check"></i><b>10.2.5</b> Primeri poslovnih sistemov</a></li>
<li class="chapter" data-level="10.2.6" data-path="P5.html"><a href="P5.html#poslovni-sistemi-in-poslovne-funkcije"><i class="fa fa-check"></i><b>10.2.6</b> Poslovni sistemi in poslovne funkcije</a></li>
<li class="chapter" data-level="10.2.7" data-path="P5.html"><a href="P5.html#podjetja-in-poslovni-procesi"><i class="fa fa-check"></i><b>10.2.7</b> Podjetja in poslovni procesi</a></li>
<li class="chapter" data-level="10.2.8" data-path="P5.html"><a href="P5.html#primerjava-največjih-ponudnikov"><i class="fa fa-check"></i><b>10.2.8</b> Primerjava največjih ponudnikov</a></li>
<li class="chapter" data-level="10.2.9" data-path="P5.html"><a href="P5.html#zgodovina-sistema-sap"><i class="fa fa-check"></i><b>10.2.9</b> Zgodovina sistema SAP</a></li>
<li class="chapter" data-level="10.2.10" data-path="P5.html"><a href="P5.html#komponente-poslovnih-informacijskih-sistemov"><i class="fa fa-check"></i><b>10.2.10</b> Komponente poslovnih informacijskih sistemov</a></li>
<li class="chapter" data-level="10.2.11" data-path="P5.html"><a href="P5.html#integracija-poslovnih-aplikacij"><i class="fa fa-check"></i><b>10.2.11</b> Integracija poslovnih aplikacij</a></li>
<li class="chapter" data-level="10.2.12" data-path="P5.html"><a href="P5.html#elektronska-izmenjava-podatkov"><i class="fa fa-check"></i><b>10.2.12</b> Elektronska izmenjava podatkov</a></li>
<li class="chapter" data-level="10.2.13" data-path="P5.html"><a href="P5.html#ERP-podrobnosti"><i class="fa fa-check"></i><b>10.2.13</b> ERP</a></li>
<li class="chapter" data-level="10.2.14" data-path="P5.html"><a href="P5.html#CRM-podrobnosti"><i class="fa fa-check"></i><b>10.2.14</b> CRM</a></li>
<li class="chapter" data-level="10.2.15" data-path="P5.html"><a href="P5.html#SCM-podrobnosti"><i class="fa fa-check"></i><b>10.2.15</b> SCM</a></li>
<li class="chapter" data-level="10.2.16" data-path="P5.html"><a href="P5.html#KM-podrobnosti"><i class="fa fa-check"></i><b>10.2.16</b> KM</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="11" data-path="P5-V5.html"><a href="P5-V5.html"><i class="fa fa-check"></i><b>11</b> <span class="sklop2 oznaka">P5</span> → <span class="sklop3 oznaka">V5</span> Povezovanje na podatkovno bazo</a>
<ul>
<li class="chapter" data-level="11.1" data-path="P5-V5.html"><a href="P5-V5.html#priprava-okolja"><i class="fa fa-check"></i><b>11.1</b> Priprava okolja</a></li>
<li class="chapter" data-level="11.2" data-path="P5-V5.html"><a href="P5-V5.html#razširitev-arhitekture-odjemalecstrežnik-s-podatkovno-bazo"><i class="fa fa-check"></i><b>11.2</b> Razširitev arhitekture odjemalec/strežnik s podatkovno bazo</a></li>
<li class="chapter" data-level="11.3" data-path="P5-V5.html"><a href="P5-V5.html#chinook-podatkovna-baza"><i class="fa fa-check"></i><b>11.3</b> Chinook podatkovna baza</a></li>
<li class="chapter" data-level="11.4" data-path="P5-V5.html"><a href="P5-V5.html#poizvedovalni-jezik-sql"><i class="fa fa-check"></i><b>11.4</b> Poizvedovalni jezik SQL</a></li>
<li class="chapter" data-level="11.5" data-path="P5-V5.html"><a href="P5-V5.html#podatkovna-baza-sqlite"><i class="fa fa-check"></i><b>11.5</b> Podatkovna baza SQLite</a>
<ul>
<li class="chapter" data-level="11.5.1" data-path="P5-V5.html"><a href="P5-V5.html#vsebina-podatkovne-baze"><i class="fa fa-check"></i><b>11.5.1</b> Vsebina podatkovne baze</a></li>
<li class="chapter" data-level="11.5.2" data-path="P5-V5.html"><a href="P5-V5.html#namestitev-knjižnic"><i class="fa fa-check"></i><b>11.5.2</b> Namestitev knjižnic</a></li>
<li class="chapter" data-level="11.5.3" data-path="P5-V5.html"><a href="P5-V5.html#prikaz-vseh-vrednosti-v-tabeli"><i class="fa fa-check"></i><b>11.5.3</b> Prikaz vseh vrednosti v tabeli</a></li>
<li class="chapter" data-level="11.5.4" data-path="P5-V5.html"><a href="P5-V5.html#filtriranje-zapisov"><i class="fa fa-check"></i><b>11.5.4</b> Filtriranje zapisov</a></li>
<li class="chapter" data-level="11.5.5" data-path="P5-V5.html"><a href="P5-V5.html#prikaz-podatkov-iz-več-tabel"><i class="fa fa-check"></i><b>11.5.5</b> Prikaz podatkov iz več tabel</a></li>
</ul></li>
<li class="chapter" data-level="11.6" data-path="P5-V5.html"><a href="P5-V5.html#uporaba-ogrodja-express.js-za-poenostavitev-razvoja-aplikacij"><i class="fa fa-check"></i><b>11.6</b> Uporaba ogrodja Express.js za poenostavitev razvoja aplikacij</a>
<ul>
<li class="chapter" data-level="11.6.1" data-path="P5-V5.html"><a href="P5-V5.html#namestitev-knjižnic-1"><i class="fa fa-check"></i><b>11.6.1</b> Namestitev knjižnic</a></li>
<li class="chapter" data-level="11.6.2" data-path="P5-V5.html"><a href="P5-V5.html#hello-world-brez-uporabe-express"><i class="fa fa-check"></i><b>11.6.2</b> Hello World brez uporabe Express</a></li>
<li class="chapter" data-level="11.6.3" data-path="P5-V5.html"><a href="P5-V5.html#hello-world-z-express"><i class="fa fa-check"></i><b>11.6.3</b> Hello World z Express</a></li>
</ul></li>
<li class="chapter" data-level="11.7" data-path="P5-V5.html"><a href="P5-V5.html#master-detail-načrtovalski-vzorec"><i class="fa fa-check"></i><b>11.7</b> Master-detail načrtovalski vzorec</a></li>
<li class="chapter" data-level="11.8" data-path="P5-V5.html"><a href="P5-V5.html#primer-pesmi-po-žanrih"><i class="fa fa-check"></i><b>11.8</b> Primer: Pesmi po žanrih</a>
<ul>
<li class="chapter" data-level="11.8.1" data-path="P5-V5.html"><a href="P5-V5.html#potrebne-knjižnice"><i class="fa fa-check"></i><b>11.8.1</b> Potrebne knjižnice</a></li>
<li class="chapter" data-level="11.8.2" data-path="P5-V5.html"><a href="P5-V5.html#funkcija-ki-v-povratnem-klicu-vrača-seznam-žanrov"><i class="fa fa-check"></i><b>11.8.2</b> Funkcija, ki v povratnem klicu vrača seznam žanrov</a></li>
<li class="chapter" data-level="11.8.3" data-path="P5-V5.html"><a href="P5-V5.html#zaključek-osnovne-funkcionalnosti-strežnika"><i class="fa fa-check"></i><b>11.8.3</b> Zaključek osnovne funkcionalnosti strežnika</a></li>
<li class="chapter" data-level="11.8.4" data-path="P5-V5.html"><a href="P5-V5.html#testiranje-osnovne-funkcionalnosti-master"><i class="fa fa-check"></i><b>11.8.4</b> Testiranje osnovne funkcionalnosti (master)</a></li>
<li class="chapter" data-level="11.8.5" data-path="P5-V5.html"><a href="P5-V5.html#dodajanje-seznama-pesmi-detail"><i class="fa fa-check"></i><b>11.8.5</b> Dodajanje seznama pesmi (detail)</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="12" data-path="P6.html"><a href="P6.html"><i class="fa fa-check"></i><b>12</b> <span class="sklop2 oznaka">P6</span> Zgodovina, ključne vloge in vrste IS</a>
<ul>
<li class="chapter" data-level="12.1" data-path="P6.html"><a href="P6.html#e-poslovanje"><i class="fa fa-check"></i><b>12.1</b> E-poslovanje</a></li>
<li class="chapter" data-level="12.2" data-path="P6.html"><a href="P6.html#e-trgovanje"><i class="fa fa-check"></i><b>12.2</b> E-trgovanje</a>
<ul>
<li class="chapter" data-level="12.2.1" data-path="P6.html"><a href="P6.html#zgodovina-e-trgovanja"><i class="fa fa-check"></i><b>12.2.1</b> Zgodovina e-trgovanja</a></li>
<li class="chapter" data-level="12.2.2" data-path="P6.html"><a href="P6.html#tehnologije-e-trgovanja"><i class="fa fa-check"></i><b>12.2.2</b> Tehnologije e-trgovanja</a></li>
<li class="chapter" data-level="12.2.3" data-path="P6.html"><a href="P6.html#osnovne-komponente-e-trgovanja"><i class="fa fa-check"></i><b>12.2.3</b> Osnovne komponente e-trgovanja</a></li>
</ul></li>
<li class="chapter" data-level="12.3" data-path="P6.html"><a href="P6.html#zgodovina-in-ključne-vloge-is"><i class="fa fa-check"></i><b>12.3</b> Zgodovina in ključne vloge IS</a>
<ul>
<li class="chapter" data-level="12.3.1" data-path="P6.html"><a href="P6.html#zgodovinski-pregled-pomembnih-dogodkov-v-računalništvu"><i class="fa fa-check"></i><b>12.3.1</b> Zgodovinski pregled pomembnih dogodkov v računalništvu</a></li>
<li class="chapter" data-level="12.3.2" data-path="P6.html"><a href="P6.html#razvoj-tehnologij"><i class="fa fa-check"></i><b>12.3.2</b> Razvoj tehnologij</a></li>
<li class="chapter" data-level="12.3.3" data-path="P6.html"><a href="P6.html#razvoj-it-za-podporo-is"><i class="fa fa-check"></i><b>12.3.3</b> Razvoj IT za podporo IS</a></li>
<li class="chapter" data-level="12.3.4" data-path="P6.html"><a href="P6.html#razvoj-informacijske-podpore-po-ravneh-odločanja"><i class="fa fa-check"></i><b>12.3.4</b> Razvoj informacijske podpore po ravneh odločanja</a></li>
<li class="chapter" data-level="12.3.5" data-path="P6.html"><a href="P6.html#zgodovina-informacijskih-sistemov"><i class="fa fa-check"></i><b>12.3.5</b> Zgodovina informacijskih sistemov</a></li>
</ul></li>
<li class="chapter" data-level="12.4" data-path="P6.html"><a href="P6.html#vrste-informacijskih-sistemov"><i class="fa fa-check"></i><b>12.4</b> Vrste informacijskih sistemov</a>
<ul>
<li class="chapter" data-level="12.4.1" data-path="P6.html"><a href="P6.html#sistemi-za-podporo-poslovanju"><i class="fa fa-check"></i><b>12.4.1</b> Sistemi za podporo poslovanju</a></li>
<li class="chapter" data-level="12.4.2" data-path="P6.html"><a href="P6.html#sistemi-za-podporo-odločanju"><i class="fa fa-check"></i><b>12.4.2</b> Sistemi za podporo odločanju</a></li>
<li class="chapter" data-level="12.4.3" data-path="P6.html"><a href="P6.html#specializirani-sistemi"><i class="fa fa-check"></i><b>12.4.3</b> Specializirani sistemi</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="13" data-path="P6-V6.html"><a href="P6-V6.html"><i class="fa fa-check"></i><b>13</b> <span class="sklop2 oznaka">P6</span> → <span class="sklop3 oznaka">V6</span> Seja, košarica, XML in e-SLOG</a>
<ul>
<li class="chapter" data-level="13.1" data-path="P6-V6.html"><a href="P6-V6.html#priprava-okolja-1"><i class="fa fa-check"></i><b>13.1</b> Priprava okolja</a></li>
<li class="chapter" data-level="13.2" data-path="P6-V6.html"><a href="P6-V6.html#namestitev-knjižnic-in-vključitev-podatkovne-baze"><i class="fa fa-check"></i><b>13.2</b> Namestitev knjižnic in vključitev podatkovne baze</a></li>
<li class="chapter" data-level="13.3" data-path="P6-V6.html"><a href="P6-V6.html#seja"><i class="fa fa-check"></i><b>13.3</b> Seja</a>
<ul>
<li class="chapter" data-level="13.3.1" data-path="P6-V6.html"><a href="P6-V6.html#globalne-spremenljivke-vs.-seja"><i class="fa fa-check"></i><b>13.3.1</b> Globalne spremenljivke vs. seja</a></li>
</ul></li>
<li class="chapter" data-level="13.4" data-path="P6-V6.html"><a href="P6-V6.html#nakupovalna-košarica"><i class="fa fa-check"></i><b>13.4</b> Nakupovalna košarica</a>
<ul>
<li class="chapter" data-level="13.4.1" data-path="P6-V6.html"><a href="P6-V6.html#primer-nakupovanja-pesmi-iz-seznama-100-najbolje-prodajanih"><i class="fa fa-check"></i><b>13.4.1</b> Primer nakupovanja pesmi iz seznama 100 najbolje prodajanih</a></li>
</ul></li>
<li class="chapter" data-level="13.5" data-path="P6-V6.html"><a href="P6-V6.html#xml-in-e-slog"><i class="fa fa-check"></i><b>13.5</b> XML in e-SLOG</a>
<ul>
<li class="chapter" data-level="13.5.1" data-path="P6-V6.html"><a href="P6-V6.html#dokumentacija"><i class="fa fa-check"></i><b>13.5.1</b> Dokumentacija</a></li>
<li class="chapter" data-level="13.5.2" data-path="P6-V6.html"><a href="P6-V6.html#dopolnitve-primera-nakupovanja-pesmi"><i class="fa fa-check"></i><b>13.5.2</b> Dopolnitve primera nakupovanja pesmi</a></li>
</ul></li>
</ul></li>
<li class="part"><span><b>III sklop: Analiza, načrtovanje in razvoj poslovnih informacijskih sistemov</b></span></li>
<li class="chapter" data-level="14" data-path="P7.html"><a href="P7.html"><i class="fa fa-check"></i><b>14</b> <span class="sklop3 oznaka">P7</span> Razvojni modeli informacijskih sistemov in metodologije razvoja</a>
<ul>
<li class="chapter" data-level="14.1" data-path="P7.html"><a href="P7.html#zgodovina-razvoja-informacijskih-sistemov"><i class="fa fa-check"></i><b>14.1</b> Zgodovina razvoja informacijskih sistemov</a></li>
<li class="chapter" data-level="14.2" data-path="P7.html"><a href="P7.html#razvojni-model-informacijskega-sistema"><i class="fa fa-check"></i><b>14.2</b> Razvojni model informacijskega sistema</a>
<ul>
<li class="chapter" data-level="14.2.1" data-path="P7.html"><a href="P7.html#SDLC-studija-izvedljivosti"><i class="fa fa-check"></i><b>14.2.1</b> Študija izvedljivosti</a></li>
<li class="chapter" data-level="14.2.2" data-path="P7.html"><a href="P7.html#SDLC-zbiranje-zahtev"><i class="fa fa-check"></i><b>14.2.2</b> Zbiranje zahtev</a></li>
<li class="chapter" data-level="14.2.3" data-path="P7.html"><a href="P7.html#SDLC-analiza"><i class="fa fa-check"></i><b>14.2.3</b> Analiza</a></li>
<li class="chapter" data-level="14.2.4" data-path="P7.html"><a href="P7.html#SDLC-nacrt"><i class="fa fa-check"></i><b>14.2.4</b> Načrtovanje</a></li>
<li class="chapter" data-level="14.2.5" data-path="P7.html"><a href="P7.html#SDLC-implementacija"><i class="fa fa-check"></i><b>14.2.5</b> Implementacija</a></li>
<li class="chapter" data-level="14.2.6" data-path="P7.html"><a href="P7.html#SDLC-pregled-in-vzdrzevanje"><i class="fa fa-check"></i><b>14.2.6</b> Pregled in vzdrževanje</a></li>
</ul></li>
<li class="chapter" data-level="14.3" data-path="P7.html"><a href="P7.html#metodologija"><i class="fa fa-check"></i><b>14.3</b> Metodologija</a>
<ul>
<li class="chapter" data-level="14.3.1" data-path="P7.html"><a href="P7.html#tehnike"><i class="fa fa-check"></i><b>14.3.1</b> Tehnike</a></li>
<li class="chapter" data-level="14.3.2" data-path="P7.html"><a href="P7.html#orodja"><i class="fa fa-check"></i><b>14.3.2</b> Orodja</a></li>
</ul></li>
<li class="chapter" data-level="14.4" data-path="P7.html"><a href="P7.html#variante-razvojnih-modelov-informacijskih-sistemov"><i class="fa fa-check"></i><b>14.4</b> Variante razvojnih modelov informacijskih sistemov</a>
<ul>
<li class="chapter" data-level="14.4.1" data-path="P7.html"><a href="P7.html#Zaporedni-razvojni-model"><i class="fa fa-check"></i><b>14.4.1</b> Zaporedni oz. slapovni razvojni model</a></li>
<li class="chapter" data-level="14.4.2" data-path="P7.html"><a href="P7.html#Iterativni-razvojni-model"><i class="fa fa-check"></i><b>14.4.2</b> Iterativni razvojni model</a></li>
<li class="chapter" data-level="14.4.3" data-path="P7.html"><a href="P7.html#Prototipni-razvojni-model"><i class="fa fa-check"></i><b>14.4.3</b> Prototipni razvojni model</a></li>
<li class="chapter" data-level="14.4.4" data-path="P7.html"><a href="P7.html#Iterativni-prototipni-razvojni-model"><i class="fa fa-check"></i><b>14.4.4</b> Iterativni/prototipni razvojni model</a></li>
<li class="chapter" data-level="14.4.5" data-path="P7.html"><a href="P7.html#Inkrementalni-razvojni-model"><i class="fa fa-check"></i><b>14.4.5</b> Inkrementalni razvojni model</a></li>
<li class="chapter" data-level="14.4.6" data-path="P7.html"><a href="P7.html#iterativnost-vs.-inkrementalnost"><i class="fa fa-check"></i><b>14.4.6</b> Iterativnost vs. inkrementalnost</a></li>
<li class="chapter" data-level="14.4.7" data-path="P7.html"><a href="P7.html#Kombinirani-razvojni-model"><i class="fa fa-check"></i><b>14.4.7</b> Kombinirani razvojni model</a></li>
</ul></li>
<li class="chapter" data-level="14.5" data-path="P7.html"><a href="P7.html#metodologije-razvoja"><i class="fa fa-check"></i><b>14.5</b> Metodologije razvoja</a>
<ul>
<li class="chapter" data-level="14.5.1" data-path="P7.html"><a href="P7.html#različne-opredelitve-v-literaturi"><i class="fa fa-check"></i><b>14.5.1</b> Različne opredelitve v literaturi</a></li>
<li class="chapter" data-level="14.5.2" data-path="P7.html"><a href="P7.html#metodologija-v-terminološkem-slovarju"><i class="fa fa-check"></i><b>14.5.2</b> Metodologija v terminološkem slovarju</a></li>
<li class="chapter" data-level="14.5.3" data-path="P7.html"><a href="P7.html#naša-opredelitev"><i class="fa fa-check"></i><b>14.5.3</b> Naša opredelitev</a></li>
<li class="chapter" data-level="14.5.4" data-path="P7.html"><a href="P7.html#elementi-metodologije"><i class="fa fa-check"></i><b>14.5.4</b> Elementi metodologije</a></li>
<li class="chapter" data-level="14.5.5" data-path="P7.html"><a href="P7.html#upravljanje-z-znanjem"><i class="fa fa-check"></i><b>14.5.5</b> Upravljanje z znanjem</a></li>
<li class="chapter" data-level="14.5.6" data-path="P7.html"><a href="P7.html#formalna-vs.-neformalna-metodologija"><i class="fa fa-check"></i><b>14.5.6</b> Formalna vs. neformalna metodologija</a></li>
<li class="chapter" data-level="14.5.7" data-path="P7.html"><a href="P7.html#agilni-koncepti-in-metodologije"><i class="fa fa-check"></i><b>14.5.7</b> Agilni koncepti in metodologije</a></li>
<li class="chapter" data-level="14.5.8" data-path="P7.html"><a href="P7.html#metamodel-metodologije-razvoja-informacijskega-sistema"><i class="fa fa-check"></i><b>14.5.8</b> Metamodel metodologije razvoja informacijskega sistema</a></li>
<li class="chapter" data-level="14.5.9" data-path="P7.html"><a href="P7.html#ogrodja-za-primerjavo-metodologij"><i class="fa fa-check"></i><b>14.5.9</b> Ogrodja za primerjavo metodologij</a></li>
<li class="chapter" data-level="14.5.10" data-path="P7.html"><a href="P7.html#učinkovitost-različnih-oblik-komunikacije"><i class="fa fa-check"></i><b>14.5.10</b> Učinkovitost različnih oblik komunikacije</a></li>
<li class="chapter" data-level="14.5.11" data-path="P7.html"><a href="P7.html#vpliv-velikosti-na-posebnosti-razvojne-skupine"><i class="fa fa-check"></i><b>14.5.11</b> Vpliv velikosti na posebnosti razvojne skupine</a></li>
<li class="chapter" data-level="14.5.12" data-path="P7.html"><a href="P7.html#Kriticni-projekti"><i class="fa fa-check"></i><b>14.5.12</b> Kritični projekti</a></li>
<li class="chapter" data-level="14.5.13" data-path="P7.html"><a href="P7.html#Komunikacija-in-povratne-informacije"><i class="fa fa-check"></i><b>14.5.13</b> Komunikacija in povratne informacije</a></li>
<li class="chapter" data-level="14.5.14" data-path="P7.html"><a href="P7.html#primer-google-inženirji-vs.-managerji"><i class="fa fa-check"></i><b>14.5.14</b> Primer: Google: Inženirji vs. managerji</a></li>
<li class="chapter" data-level="14.5.15" data-path="P7.html"><a href="P7.html#Discipliniranost-izkusnje-in-znanje"><i class="fa fa-check"></i><b>14.5.15</b> Discipliniranost, izkušnje in znanje</a></li>
<li class="chapter" data-level="14.5.16" data-path="P7.html"><a href="P7.html#Odkloni-od-nacrtovane-resitve"><i class="fa fa-check"></i><b>14.5.16</b> Odkloni od načrtovane rešitve</a></li>
<li class="chapter" data-level="14.5.17" data-path="P7.html"><a href="P7.html#evolucija-razvoja-programske-opreme"><i class="fa fa-check"></i><b>14.5.17</b> Evolucija razvoja programske opreme</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="15" data-path="P8.html"><a href="P8.html"><i class="fa fa-check"></i><b>15</b> <span class="sklop3 oznaka">P8</span> Strukturni razvoj</a>
<ul>
<li class="chapter" data-level="15.1" data-path="P8.html"><a href="P8.html#uvod-v-strukturni-razvoj"><i class="fa fa-check"></i><b>15.1</b> Uvod v strukturni razvoj</a>
<ul>
<li class="chapter" data-level="15.1.1" data-path="P8.html"><a href="P8.html#Strukturni-zajem-in-specifikaija-zahtev"><i class="fa fa-check"></i><b>15.1.1</b> Zajem in specifikacija zahtev</a></li>
<li class="chapter" data-level="15.1.2" data-path="P8.html"><a href="P8.html#Strukturni-analiza"><i class="fa fa-check"></i><b>15.1.2</b> Analiza</a></li>
<li class="chapter" data-level="15.1.3" data-path="P8.html"><a href="P8.html#Strukturni-nacrtovanje"><i class="fa fa-check"></i><b>15.1.3</b> Načrtovanje</a></li>
<li class="chapter" data-level="15.1.4" data-path="P8.html"><a href="P8.html#Strukturni-testiranje"><i class="fa fa-check"></i><b>15.1.4</b> Testiranje</a></li>
<li class="chapter" data-level="15.1.5" data-path="P8.html"><a href="P8.html#Strukturni-namestitev-in-uvedba"><i class="fa fa-check"></i><b>15.1.5</b> Namestitev in uvedba</a></li>
</ul></li>
<li class="chapter" data-level="15.2" data-path="P8.html"><a href="P8.html#podatkovno-načrtovanje"><i class="fa fa-check"></i><b>15.2</b> Podatkovno načrtovanje</a>
<ul>
<li class="chapter" data-level="15.2.1" data-path="P8.html"><a href="P8.html#relacijski-model"><i class="fa fa-check"></i><b>15.2.1</b> Relacijski model</a></li>
<li class="chapter" data-level="15.2.2" data-path="P8.html"><a href="P8.html#matematična-opredelitev"><i class="fa fa-check"></i><b>15.2.2</b> Matematična opredelitev</a></li>
<li class="chapter" data-level="15.2.3" data-path="P8.html"><a href="P8.html#entitetni-diagram"><i class="fa fa-check"></i><b>15.2.3</b> Entitetni diagram</a></li>
<li class="chapter" data-level="15.2.4" data-path="P8.html"><a href="P8.html#različne-ravni-podatkovnega-modeliranja"><i class="fa fa-check"></i><b>15.2.4</b> Različne ravni podatkovnega modeliranja</a></li>
<li class="chapter" data-level="15.2.5" data-path="P8.html"><a href="P8.html#Postopek-konceptualno-nacrtovanje"><i class="fa fa-check"></i><b>15.2.5</b> Konceptualno načrtovanje</a></li>
<li class="chapter" data-level="15.2.6" data-path="P8.html"><a href="P8.html#prehod-iz-konceptualnega-v-logično-načrtovanje"><i class="fa fa-check"></i><b>15.2.6</b> Prehod iz konceptualnega v logično načrtovanje</a></li>
<li class="chapter" data-level="15.2.7" data-path="P8.html"><a href="P8.html#logično-načrtovanje"><i class="fa fa-check"></i><b>15.2.7</b> Logično načrtovanje</a></li>
</ul></li>
<li class="chapter" data-level="15.3" data-path="P8.html"><a href="P8.html#Postopek-normalizacija"><i class="fa fa-check"></i><b>15.3</b> Normalizacija</a>
<ul>
<li class="chapter" data-level="15.3.1" data-path="P8.html"><a href="P8.html#normalna-oblika-1.-no"><i class="fa fa-check"></i><b>15.3.1</b> 1. normalna oblika (1. NO)</a></li>
<li class="chapter" data-level="15.3.2" data-path="P8.html"><a href="P8.html#normalna-oblika-2.-no"><i class="fa fa-check"></i><b>15.3.2</b> 2. normalna oblika (2. NO)</a></li>
<li class="chapter" data-level="15.3.3" data-path="P8.html"><a href="P8.html#normalna-oblika-3.-no"><i class="fa fa-check"></i><b>15.3.3</b> 3. normalna oblika (3. NO)</a></li>
<li class="chapter" data-level="15.3.4" data-path="P8.html"><a href="P8.html#poslovna-normalna-oblika-4.-pno"><i class="fa fa-check"></i><b>15.3.4</b> 4. poslovna normalna oblika (4. PNO)</a></li>
<li class="chapter" data-level="15.3.5" data-path="P8.html"><a href="P8.html#poslovna-normalna-oblika-5.-pno"><i class="fa fa-check"></i><b>15.3.5</b> 5. poslovna normalna oblika (5. PNO)</a></li>
</ul></li>
<li class="chapter" data-level="15.4" data-path="P8.html"><a href="P8.html#denormalizacija"><i class="fa fa-check"></i><b>15.4</b> Denormalizacija</a></li>
<li class="chapter" data-level="15.5" data-path="P8.html"><a href="P8.html#primeri-normalizacije"><i class="fa fa-check"></i><b>15.5</b> Primeri normalizacije</a>
<ul>
<li class="chapter" data-level="15.5.1" data-path="P8.html"><a href="P8.html#normalizacija-računa"><i class="fa fa-check"></i><b>15.5.1</b> Normalizacija računa</a></li>
<li class="chapter" data-level="15.5.2" data-path="P8.html"><a href="P8.html#normalizacija-reverza"><i class="fa fa-check"></i><b>15.5.2</b> Normalizacija reverza</a></li>
</ul></li>
<li class="chapter" data-level="15.6" data-path="P8.html"><a href="P8.html#procesni-vidik"><i class="fa fa-check"></i><b>15.6</b> Procesni vidik</a>
<ul>
<li class="chapter" data-level="15.6.1" data-path="P8.html"><a href="P8.html#dekompozicijski-diagrami"><i class="fa fa-check"></i><b>15.6.1</b> Dekompozicijski diagrami</a></li>
<li class="chapter" data-level="15.6.2" data-path="P8.html"><a href="P8.html#procesna-logika"><i class="fa fa-check"></i><b>15.6.2</b> Procesna logika</a></li>
<li class="chapter" data-level="15.6.3" data-path="P8.html"><a href="P8.html#BPMN-tehnika"><i class="fa fa-check"></i><b>15.6.3</b> BPMN</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="16" data-path="P9.html"><a href="P9.html"><i class="fa fa-check"></i><b>16</b> <span class="sklop3 oznaka">P9</span> Objektno usmerjena analiza, načrtovanje in modeliranje</a>
<ul>
<li class="chapter" data-level="16.1" data-path="P9.html"><a href="P9.html#objektno-usmerjena-analiza-in-načrtovanje"><i class="fa fa-check"></i><b>16.1</b> Objektno usmerjena analiza in načrtovanje</a>
<ul>
<li class="chapter" data-level="16.1.1" data-path="P9.html"><a href="P9.html#OO-thinking"><i class="fa fa-check"></i><b>16.1.1</b> Objektno usmerjeno razmišljanje</a></li>
<li class="chapter" data-level="16.1.2" data-path="P9.html"><a href="P9.html#načrtovanje-v-procesu-razvoja-programske-opreme"><i class="fa fa-check"></i><b>16.1.2</b> Načrtovanje v procesu razvoja programske opreme</a></li>
<li class="chapter" data-level="16.1.3" data-path="P9.html"><a href="P9.html#načrtovanje-z-upoštevanjem-kakovosti"><i class="fa fa-check"></i><b>16.1.3</b> Načrtovanje z upoštevanjem kakovosti</a></li>
<li class="chapter" data-level="16.1.4" data-path="P9.html"><a href="P9.html#razred-odgovornost-sodelovanje"><i class="fa fa-check"></i><b>16.1.4</b> Razred, odgovornost, sodelovanje</a></li>
</ul></li>
<li class="chapter" data-level="16.2" data-path="P9.html"><a href="P9.html#objektno-usmerjeno-načrtovanje"><i class="fa fa-check"></i><b>16.2</b> Objektno usmerjeno načrtovanje</a>
<ul>
<li class="chapter" data-level="16.2.1" data-path="P9.html"><a href="P9.html#izdelava-modelov-načrta"><i class="fa fa-check"></i><b>16.2.1</b> Izdelava modelov načrta</a></li>
<li class="chapter" data-level="16.2.2" data-path="P9.html"><a href="P9.html#razvoj-programskih-jezikov"><i class="fa fa-check"></i><b>16.2.2</b> Razvoj programskih jezikov</a></li>
<li class="chapter" data-level="16.2.3" data-path="P9.html"><a href="P9.html#stiri-nacrtovalska-nacela"><i class="fa fa-check"></i><b>16.2.3</b> Štiri načrtovalska načela</a></li>
<li class="chapter" data-level="16.2.4" data-path="P9.html"><a href="P9.html#načrtovalska-struktura-v-programskem-jeziku-java-in-uml-razrednih-diagramih"><i class="fa fa-check"></i><b>16.2.4</b> Načrtovalska struktura v programskem jeziku Java in UML razrednih diagramih</a></li>
</ul></li>
<li class="chapter" data-level="16.3" data-path="P9.html"><a href="P9.html#načrtovalska-načela"><i class="fa fa-check"></i><b>16.3</b> Načrtovalska načela</a>
<ul>
<li class="chapter" data-level="16.3.1" data-path="P9.html"><a href="P9.html#vrednotenje-kompleksnosti-načrta"><i class="fa fa-check"></i><b>16.3.1</b> Vrednotenje kompleksnosti načrta</a></li>
<li class="chapter" data-level="16.3.2" data-path="P9.html"><a href="P9.html#načelo-ločevanja-pomislekov"><i class="fa fa-check"></i><b>16.3.2</b> Načelo ločevanja pomislekov</a></li>
<li class="chapter" data-level="16.3.3" data-path="P9.html"><a href="P9.html#skrivanje-informacij"><i class="fa fa-check"></i><b>16.3.3</b> Skrivanje informacij</a></li>
<li class="chapter" data-level="16.3.4" data-path="P9.html"><a href="P9.html#konceptualna-celovitost"><i class="fa fa-check"></i><b>16.3.4</b> Konceptualna celovitost</a></li>
<li class="chapter" data-level="16.3.5" data-path="P9.html"><a href="P9.html#načela-posploševanja"><i class="fa fa-check"></i><b>16.3.5</b> Načela posploševanja</a></li>
<li class="chapter" data-level="16.3.6" data-path="P9.html"><a href="P9.html#preverjanje-modela"><i class="fa fa-check"></i><b>16.3.6</b> Preverjanje modela</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="17" data-path="P10.html"><a href="P10.html"><i class="fa fa-check"></i><b>17</b> <span class="sklop3 oznaka">P10</span> Objektni razvoj, simulacija razvoja informacijskega sistema za bankomat in simulacija projekta</a>
<ul>
<li class="chapter" data-level="17.1" data-path="P10.html"><a href="P10.html#objektni-razvoj"><i class="fa fa-check"></i><b>17.1</b> Objektni razvoj</a>
<ul>
<li class="chapter" data-level="17.1.1" data-path="P10.html"><a href="P10.html#rup-proces-razvoja"><i class="fa fa-check"></i><b>17.1.1</b> RUP proces razvoja</a></li>
</ul></li>
<li class="chapter" data-level="17.2" data-path="P10.html"><a href="P10.html#simulacija-razvoja-informacijskega-sistema-za-bankomat"><i class="fa fa-check"></i><b>17.2</b> Simulacija razvoja informacijskega sistema za bankomat</a>
<ul>
<li class="chapter" data-level="17.2.1" data-path="P10.html"><a href="P10.html#predstavitev-problema"><i class="fa fa-check"></i><b>17.2.1</b> Predstavitev problema</a></li>
<li class="chapter" data-level="17.2.2" data-path="P10.html"><a href="P10.html#Bankomat-Zbiranje-zahtev"><i class="fa fa-check"></i><b>17.2.2</b> Zajem zahtev</a></li>
<li class="chapter" data-level="17.2.3" data-path="P10.html"><a href="P10.html#Bankomat-Analiza"><i class="fa fa-check"></i><b>17.2.3</b> Analiza</a></li>
<li class="chapter" data-level="17.2.4" data-path="P10.html"><a href="P10.html#Bankomat-Pregledni-nacrt"><i class="fa fa-check"></i><b>17.2.4</b> Pregledni načrt</a></li>
<li class="chapter" data-level="17.2.5" data-path="P10.html"><a href="P10.html#Bankomat-Podroben-nacrt"><i class="fa fa-check"></i><b>17.2.5</b> Podroben načrt</a></li>
<li class="chapter" data-level="17.2.6" data-path="P10.html"><a href="P10.html#Bankomat-Implementacija"><i class="fa fa-check"></i><b>17.2.6</b> Implementacija</a></li>
</ul></li>
<li class="chapter" data-level="17.3" data-path="P10.html"><a href="P10.html#Simulacija-projekta"><i class="fa fa-check"></i><b>17.3</b> Simulacija projekta</a>
<ul>
<li class="chapter" data-level="17.3.1" data-path="P10.html"><a href="P10.html#pravila"><i class="fa fa-check"></i><b>17.3.1</b> Pravila</a></li>
<li class="chapter" data-level="17.3.2" data-path="P10.html"><a href="P10.html#izračun-točk-simulacije"><i class="fa fa-check"></i><b>17.3.2</b> Izračun točk simulacije</a></li>
<li class="chapter" data-level="17.3.3" data-path="P10.html"><a href="P10.html#potek-simulacije"><i class="fa fa-check"></i><b>17.3.3</b> Potek simulacije</a></li>
<li class="chapter" data-level="17.3.4" data-path="P10.html"><a href="P10.html#gradivo"><i class="fa fa-check"></i><b>17.3.4</b> Gradivo</a></li>
<li class="chapter" data-level="17.3.5" data-path="P10.html"><a href="P10.html#nakljucni-dogodki-simulacije"><i class="fa fa-check"></i><b>17.3.5</b> Naključni dogodki pri simulaciji</a></li>
</ul></li>
</ul></li>
<li class="part"><span><b>IV sklop: Infrastruktura in trendi</b></span></li>
<li class="chapter" data-level="18" data-path="P11.html"><a href="P11.html"><i class="fa fa-check"></i><b>18</b> <span class="sklop4 oznaka">P11</span> Semantični splet in tehnologija veriženja blokov</a>
<ul>
<li class="chapter" data-level="18.1" data-path="P11.html"><a href="P11.html#semantični-splet"><i class="fa fa-check"></i><b>18.1</b> Semantični splet</a>
<ul>
<li class="chapter" data-level="18.1.1" data-path="P11.html"><a href="P11.html#splet-v-številkah"><i class="fa fa-check"></i><b>18.1.1</b> Splet v številkah</a></li>
<li class="chapter" data-level="18.1.2" data-path="P11.html"><a href="P11.html#iskalniki-najdejo-le-del-spleta"><i class="fa fa-check"></i><b>18.1.2</b> Iskalniki “najdejo” le del spleta</a></li>
<li class="chapter" data-level="18.1.3" data-path="P11.html"><a href="P11.html#vloga-svetovnega-spleta"><i class="fa fa-check"></i><b>18.1.3</b> Vloga svetovnega spleta</a></li>
<li class="chapter" data-level="18.1.4" data-path="P11.html"><a href="P11.html#semantična-integracija-podatkov"><i class="fa fa-check"></i><b>18.1.4</b> Semantična integracija podatkov</a></li>
<li class="chapter" data-level="18.1.5" data-path="P11.html"><a href="P11.html#primer-organizacije-potovanj"><i class="fa fa-check"></i><b>18.1.5</b> Primer organizacije potovanj</a></li>
<li class="chapter" data-level="18.1.6" data-path="P11.html"><a href="P11.html#osnova-so-podatki"><i class="fa fa-check"></i><b>18.1.6</b> Osnova so podatki</a></li>
<li class="chapter" data-level="18.1.7" data-path="P11.html"><a href="P11.html#semantični-splet-1"><i class="fa fa-check"></i><b>18.1.7</b> Semantični splet</a></li>
<li class="chapter" data-level="18.1.8" data-path="P11.html"><a href="P11.html#web-x"><i class="fa fa-check"></i><b>18.1.8</b> Web X</a></li>
</ul></li>
<li class="chapter" data-level="18.2" data-path="P11.html"><a href="P11.html#tehnologija-veriženja-blokov"><i class="fa fa-check"></i><b>18.2</b> Tehnologija veriženja blokov</a>
<ul>
<li class="chapter" data-level="18.2.1" data-path="P11.html"><a href="P11.html#uvod-v-osnovne-pojme"><i class="fa fa-check"></i><b>18.2.1</b> Uvod v osnovne pojme</a></li>
<li class="chapter" data-level="18.2.2" data-path="P11.html"><a href="P11.html#osnovni-princip-delovanja"><i class="fa fa-check"></i><b>18.2.2</b> Osnovni princip delovanja</a></li>
<li class="chapter" data-level="18.2.3" data-path="P11.html"><a href="P11.html#zgodovinski-pregled-razvoja-in-trendov-tehnologije-veriženja-blokov"><i class="fa fa-check"></i><b>18.2.3</b> Zgodovinski pregled razvoja in trendov tehnologije veriženja blokov</a></li>
<li class="chapter" data-level="18.2.4" data-path="P11.html"><a href="P11.html#mehanizmi-soglasja"><i class="fa fa-check"></i><b>18.2.4</b> Mehanizmi soglasja</a></li>
<li class="chapter" data-level="18.2.5" data-path="P11.html"><a href="P11.html#področja-uporabe-tehnologije-veriženja-blokov"><i class="fa fa-check"></i><b>18.2.5</b> Področja uporabe tehnologije veriženja blokov</a></li>
<li class="chapter" data-level="18.2.6" data-path="P11.html"><a href="P11.html#pametne-pogodbe"><i class="fa fa-check"></i><b>18.2.6</b> Pametne pogodbe</a></li>
<li class="chapter" data-level="18.2.7" data-path="P11.html"><a href="P11.html#kdaj-uporabiti-tehnologijo-veriženja-blokov"><i class="fa fa-check"></i><b>18.2.7</b> Kdaj uporabiti tehnologijo veriženja blokov?</a></li>
<li class="chapter" data-level="18.2.8" data-path="P11.html"><a href="P11.html#projekti-na-fakulteti"><i class="fa fa-check"></i><b>18.2.8</b> Projekti na fakulteti</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="19" data-path="P12.html"><a href="P12.html"><i class="fa fa-check"></i><b>19</b> <span class="sklop5 oznaka">P12</span> Računalništvo v oblaku, IT varnost in Marshmallow challenge</a>
<ul>
<li class="chapter" data-level="19.1" data-path="P12.html"><a href="P12.html#računalništvo-v-oblaku"><i class="fa fa-check"></i><b>19.1</b> Računalništvo v oblaku</a>
<ul>
<li class="chapter" data-level="19.1.1" data-path="P12.html"><a href="P12.html#izbira-oblačne-storitve"><i class="fa fa-check"></i><b>19.1.1</b> Izbira oblačne storitve</a></li>
<li class="chapter" data-level="19.1.2" data-path="P12.html"><a href="P12.html#realizacija-računalništva-v-oblaku"><i class="fa fa-check"></i><b>19.1.2</b> Realizacija računalništva v oblaku</a></li>
<li class="chapter" data-level="19.1.3" data-path="P12.html"><a href="P12.html#virtualizacija"><i class="fa fa-check"></i><b>19.1.3</b> Virtualizacija</a></li>
<li class="chapter" data-level="19.1.4" data-path="P12.html"><a href="P12.html#modeli-računalništva-v-oblaku"><i class="fa fa-check"></i><b>19.1.4</b> Modeli računalništva v oblaku</a></li>
</ul></li>
<li class="chapter" data-level="19.2" data-path="P12.html"><a href="P12.html#it-varnost"><i class="fa fa-check"></i><b>19.2</b> IT varnost</a>
<ul>
<li class="chapter" data-level="19.2.1" data-path="P12.html"><a href="P12.html#napadi"><i class="fa fa-check"></i><b>19.2.1</b> Napadi</a></li>
<li class="chapter" data-level="19.2.2" data-path="P12.html"><a href="P12.html#najboljše-prakse-protiukrepov"><i class="fa fa-check"></i><b>19.2.2</b> Najboljše prakse protiukrepov</a></li>
<li class="chapter" data-level="19.2.3" data-path="P12.html"><a href="P12.html#postopek-razkrivanja-ranljivosti"><i class="fa fa-check"></i><b>19.2.3</b> Postopek razkrivanja ranljivosti</a></li>
</ul></li>
<li class="chapter" data-level="19.3" data-path="P12.html"><a href="P12.html#marshmallow-challenge"><i class="fa fa-check"></i><b>19.3</b> Marshmallow challenge</a>
<ul>
<li class="chapter" data-level="19.3.1" data-path="P12.html"><a href="P12.html#izziv"><i class="fa fa-check"></i><b>19.3.1</b> Izziv</a></li>
<li class="chapter" data-level="19.3.2" data-path="P12.html"><a href="P12.html#zaključki"><i class="fa fa-check"></i><b>19.3.2</b> Zaključki</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="" data-path="literatura.html"><a href="literatura.html"><i class="fa fa-check"></i>Literatura</a></li>
<li class="divider"></li>
<li><a href="https://ucilnica.fri.uni-lj.si/course/view.php?id=54">eUčilnica</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="index.html">Osnove informacijskih sistemov 2023/2024</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="P9" class="section level1 hasAnchor" number="16">
<h1><span class="header-section-number">Poglavje 16</span> <span class="sklop3 oznaka">P9</span> Objektno usmerjena analiza, načrtovanje in modeliranje<a href="P9.html#P9" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<div class="vrstica">
<img src="assets/img/ninja/ninja_03_go_right.png">
<h3>
<span class="sklop3 oznaka">P9</span>
</h3>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js"></script>
<script>
  var options_dodaj = {acrossElements: true, element: "dodaj"};
  var options_izbrisi = {acrossElements: true, element: "izbrisi"};
</script>
<div id="objektno-usmerjena-analiza-in-načrtovanje" class="section level2 hasAnchor" number="16.1">
<h2><span class="header-section-number">16.1</span> Objektno usmerjena analiza in načrtovanje<a href="P9.html#objektno-usmerjena-analiza-in-načrtovanje" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<div id="OO-thinking" class="section level3 hasAnchor" number="16.1.1">
<h3><span class="header-section-number">16.1.1</span> Objektno usmerjeno razmišljanje<a href="P9.html#OO-thinking" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Izraz objektno usmerjen <em>(angl. object-oriented)</em> ponavadi povezujemo s kodiranjem in razvojem programske opreme. Čeprav je to pravilno, lahko pojem objektne usmerjenosti uporabimo tudi izven vloge razvijalca. Objektno usmerjeno razmišljanje vključuje preučevanje problemov ali konceptov, njihovo razčlenitev na manjše dele in razmišljanje o njih kot objektih. Npr. kratko sporočilo na Twitterju ali izdelek v spletni trgovini bi lahko obravnavali kot predmete.</p>
<p>Objekti lahko vključujejo določeno podrobnosti, ki so pomembne za uporabnike. Npr. objekta <code>Oseba</code> ima lahko podrobnosti, kot so <code>ime</code>, <code>starost</code>, <code>spol</code> in <code>poklic</code>.</p>
<p>Z objekti so lahko povezana tudi vedenja <em>(angl. behaviours)</em> oz. odgovornosti <em>(angl. responsibilities)</em>. Npr. <code>Oseba</code> lahko vsebuje vedenja, kot je <code>sedenje</code> ali <code>pisanje</code>. <code>Elektronska naprava</code> je lahko odgovorna za <code>vklop</code> ali <code>izklop</code> prikaza slike.</p>
<p>Z uporabo objektov pri predstavitvi stvari je izvorna koda programske rešitve bolje <strong>organizirana</strong>, <strong>prilagodljiva</strong> <em>(angl. flexible)</em> in <strong>ponovno uporabna</strong> <em>(angl. reusable)</em>:</p>
<ul>
<li>Objekti ohranjajo izvorno kodo organizirano tako, da povezane podrobnosti in funkcije postavijo na različna mesta, ki jih je enostavno najti. Npr. pri prejšnjih primerih so podrobnosti o objektih povezane z objekti samimi.</li>
<li>Objekti ohranjajo kodo prilagodljivo tako, da lahko podrobnosti enostavno spremenimo na modularen način znotraj objekta, brez da vplivamo na preostalo izvorno kodo. Npr. pri objektu <code>Oseba</code> se lahko spremenijo podrobnosti osebe, kot je npr. <code>poklic</code> in to ne vpliva na preostalo izvorno kodo.</li>
<li>Objekti omogočajo ponovno uporabo kode, saj zmanjšajo potrebno količino izvorne kode, ki jo moramo napisati in ohranjajo programe preproste.</li>
</ul>
<p>Objekti se v produkcijskem okolju zavedajo samega sebe, npr. mobilni telefon pozna svoje specifikacije. Podobni bi pri objektno usmerjenem načrtovanju npr. <code>Stol</code> poznal svojo <code>dimenzijo</code> in <code>lokacijo</code>.</p>
<p>Pri objektno usmerjenem razmišljanju se pogosto vse koncepte (žive ali nežive) obravnava kot objekte, kjer se vsi (tudi neživi) zavedajo samega sebe.</p>
<p>Dober pristop k objektno usmerjenem načrtovanju je razmišljanje o svetu okoli nas v smislu objektov in lastnosti, ki jih ti objekti imajo.</p>
</div>
<div id="načrtovanje-v-procesu-razvoja-programske-opreme" class="section level3 hasAnchor" number="16.1.2">
<h3><span class="header-section-number">16.1.2</span> Načrtovanje v procesu razvoja programske opreme<a href="P9.html#načrtovanje-v-procesu-razvoja-programske-opreme" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Pri razvoju programske opreme ponavadi sledimo določenemu <strong>razvojnemu procesu</strong>. Poenostavljeno, proces pregleda problem in predlaga rešitev, ki vključuje programsko opremo. Razvojni proces je ponavadi iterativne narave, kjer iteracije vsebujejo zajem zahtev identificiranega problema in uporaba le-teh pri izdelavi <strong>konceptualnih modelov zasnove</strong> in diagramov <strong>tehnične zasnove</strong>, ki se nato kasneje uporabijo za <strong>razvoj</strong> delujoče programske opreme, kar mora prestati tudi testiranje. Ta postopek se ponovi za vsako množico zahtev in na koncu nastane celovita rešitev začetnega problema.</p>
<p>Številni projekti niso uspešni, ker ne upoštevajo tega razvojnega procesa, še posebej ko se delo začne takoj s kodiranjem, medtem ko je prisotno pomanjkanje razumevanja zahtev in načrtovanja.</p>
<p>Pomembno je, da si pri oblikovanju zahtev in načrtovanju vzamemo čas, tudi če tega ne naredimo v celoti. Kodiranje namreč temelji na določenih predpostavkah in te predpostavke je težko spremeniti potem, ko se kodiranje že začne. Zahteve in načrt pa pomagajo pri razumevanju, katere predpostavke potrebujemo, da razvijemo ustrezno končno rešitev.</p>
<p>V nadaljevanju bomo na kratko pregledali korake zajema zahtev in načrtovanja pri procesu razvoja programske opreme. Ti koraki zahtevajo, da delujemo kot arhitekt, saj je potrebno razmisliti o strukturi in obnašanju programske opreme.</p>
<div id="zahteve" class="section level4 hasAnchor" number="16.1.2.1">
<h4><span class="header-section-number">16.1.2.1</span> Zahteve<a href="P9.html#zahteve" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p><strong>Zahteve</strong> <em>(angl. Requirements)</em> so pogoji oz. sposobnosti, ki morajo biti vključene v implementaciji informacijske rešitev in jih pridobimo od naročnika oz. uporabnikov. Predstavljajo izhodišče projekta, kjer moramo razumeti, kaj stranka sploh želi.</p>
<p>Da lahko uspešno zajamemo zahteve, moramo poznati več kot le strankino vizijo. Pridobivanje zahtev zato vključuje aktivno preiskovanje strankine vizije, pojasnjevanje tistega, kar morda ni bilo povedano, in postavljanje vprašanj o težavah, o katerih stranka morda sploh ni razmišljala. Na ta način lahko razumemo celoten obseg tega, kar želimo razviti in kaj želi stranka od programske rešitve, še predenj začnemo s kodiranjem.</p>
<p>Poleg določitve potreb programske rešitve, moramo razmisliti tudi o morebitnih kompromisih, ki jih bo moral naročnik sprejeti. Npr. stranka se lahko odloči, da določene funkcionalnosti ne vključi v končno rešitev, da zagotovi hitrešje delovanje, če mu je to bolj pomembno.</p>
<p>Da bi bolje razumeli zahteve, si lahko predstavljate, da ste arhitekt, ki gradi hišo. Zahteve vam omogočajo, da razumete želje lastnika, preden začnete graditi. Lastnik vam mogoče pove, katere sobe želi, vendar boste pri tem morali postaviti dodatna vprašanja o tem, če kakšna soba manjka, kakšne velikosti je hiša in posamezne sobe, morebitne omejitve v hiši glede mikrolokacije sob ali v katero smer naj bo hiša obrnjena. To nam pomaga pri razumevanju, kaj bomo gradili.</p>
</div>
<div id="nacrt" class="section level4 hasAnchor" number="16.1.2.2">
<h4><span class="header-section-number">16.1.2.2</span> Načrt<a href="P9.html#nacrt" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Ko je začetni sklop zahtev zajet, je naslednji korak pri procesu razvoja izdelava idejne konceptualno zasnove in tehnične zasnove, kjer posledično nastaneta naslednja artefakta <em>(angl. artifact)</em>: <strong>idejna zasnova</strong> <em>(angl. conceptual mock-ups)</em> in <strong>tehnični diagrami</strong> <em>(angl. technical diagrams)</em>.</p>
<div id="idejna-zasnova" class="section level5 hasAnchor" number="16.1.2.2.1">
<h5><span class="header-section-number">16.1.2.2.1</span> Idejna zasnova<a href="P9.html#idejna-zasnova" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>Idejna zasnova nastane na osnovi začetnih zahtev in opredeli ustrezne <strong>komponente</strong>, <strong>povezave</strong> in <strong>odgovornosti</strong> programske rešitve. Tehnične podrobnosti na tem mestu še niso vključene, ampak so odložene do tehnične zasnove.</p>
<p>Idejna zasnova se prikaže v obliki vizualne predstavitve, ki predstavijo način, kako nameravamo izpolniti zahteve naročnika. To lahko vključuje <strong>prototipe uporabniških vmesnikov</strong>. Primer takšnega prototipa spletne strani je prikazan na sliki <a href="P9.html#fig:GUI-mock-up#fig:GUI-mock-up">16.1</a>.</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:GUI-mock-up"></span>
<img src="assets/img/GUI_mock_up.png" alt="Primer prototipa uporabniškega vmesnika" width="200" />
<p class="caption">
Slika 16.1: Primer prototipa uporabniškega vmesnika
</p>
</div>
<p>Ne glede na to, ali gre za uporabniške vmesnike ali za samo programsko rešitev, lahko idejno zasnovo predstavljajo na roke narisane skice ali risbe, ki ste jih pripravili s pomočjo računalniških orodij. Izdelki idejne zasnove pomagajo naročniku in uporabnikom razjasniti načrtovalske odločitve, saj na enostaven način prikažejo predviden način delovanja končne rešitve ter omogočajo nadaljno razpravo.</p>
<p>Takšni prototipi ponazarjajo glavne komponente in povezave med komponentami. Ko začnete z razvojem takšnega prototipa, lažje ugotovite, katere komponente manjkajo ali morda ne delujejo. Te pomanjkljivosti potrebujejo dodatno razjasnitev s strani naročnika in morebiti dodatno načrtovanja z vidika idejne zasnove. Vsaka komponenta ima določeno nalogo, ki jo mora opraviti, kar imenuje <strong>odgovornost</strong> <em>(angl. responsibility)</em>. Prototipi ne vsebujejo tehničnih podrobnosti, saj to ne spada v idejno zasnovo.</p>
<p>Npr. če se vrnemo k analognem primeru gradnje hiše. Sestavni deli arhitekturnega primera gradnje hiše lahko vključuje: parcelo, na kateri bo hiša zgrajena, hiša in prostori v njej. Povezave lahko predstavljajo način, kako so sobe medsebojno dostopne. Hiša je odgovorna za zagotavljanje dovolj energije, vode in podpore za vse komponente, ki jo sestavljajo. Prostori v hiši, kot je npr. kuhinja, imajo lahko tudi odgovornosti, kot je zagotavljanje prostora za shranjevanje kuhinjske posode, kuhinjski aparatov, zalog hrane ter električne energije in vode za pripravo obrokov. Posebnosti glede napeljave in vodovoda v idejni zasnovi niso navedene, saj ni mogoče obravnavati v celoti, dokler idejne zasnove v celoti ne razumemo. Npr. velikost električne razdelilne omare za hišo bo odvisna od seštetih potrebo po moči vsake sobe.</p>
<p>Najboljša praksa je oblikovanje idejne zasnove, preden nadaljujemo na tehnično zasnovo. Čimbolj jasna bo idejna zasnova, boljša bo tehnična zasnova in večja je verjetnost, da bo programska oprema izdelana ustrezno.</p>
</div>
<div id="tehnična-zasnova" class="section level5 hasAnchor" number="16.1.2.2.2">
<h5><span class="header-section-number">16.1.2.2.2</span> Tehnična zasnova<a href="P9.html#tehnična-zasnova" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>Tehnična zasnova temelji na idejni zasnovi in zahtevah, kjer opredelimo tehnične podrobnosti rešitve. Pri idejni zasnovi so identificirane glavne komponente in povezave ter z njimi povezane odgovornosti programske opreme, ki se razvija. Tehnična zasnova to nadgradi tako, da opiše, kako te odgovornosti dosežemo. Tehnična zasnova ni zaključena, dokler vsaka komponenta ni zaključena, kjer vsebuje dovolj podrobno specifikacijo, da jo lahko ustrezno implementiramo.</p>
<p>Da to dosežemo, se tehnično načrtovanje začne z razdelitvijo komponent na vse manjše komponente, ki so dovolj specifične, da jih lahko podrobno načrtujemo. Če komponente razdeljujemo na dodatne komponente, kjer ima vsaka komponenta posebne odgovornosti, pridemo do ravni, kjer lahko podrobno načrtujemo določeno komponento. Končni rezultat so določene tehnične podrobnosti vsake komponente.</p>
<p>Za opredelitev tehnične zasnove uporabljamo <strong>tehnične diagrame</strong>, ki na grafični način prikažejo, kako obravnavati določen problem pri vsaki komponenti, saj idejna zasnova ni dovolj specifična, da bi zajela te informacije. Obstaja veliko različnih tehničnih diagramov, ki jih lahko uporabimo za opis strukture in obnašanje komponent, ki jih bomo spoznali pri tem predmetu. Ti diagrami nam potem pomagajajo pri usklajevanju razvojnega dela.</p>
<p>Če nadaljujemo z našim primerom gradnje hiše in se osredotočimo na tehnično zasnovo kuhinje. Kuhinja je sama po sebi sestavni del hiše, vendar potrebuje dodatne manjše komponente, kot so npr. tla. Tehnična zasnova lahko nakazuje, da bodo morala biti tla izdelana iz materiala, ki ga je enostavno čistiti, zlasti če namerava naročnik veliko kuhati.</p>
</div>
</div>
<div id="kompromisi-pri-zahtevah-in-načrtovanju" class="section level4 hasAnchor" number="16.1.2.3">
<h4><span class="header-section-number">16.1.2.3</span> Kompromisi pri zahtevah in načrtovanju<a href="P9.html#kompromisi-pri-zahtevah-in-načrtovanju" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>V fazi načrtovanja bomo morda morali sprejeti kompromise pri zasnovi sprejemljive rešitve. Stalna komunikacija in povratne informacije so ključnega pomena pri zasnovi rešitve, ki ustreza potrebam naročnika in deluje v okviru morebitnih omejitev.</p>
<p>Na podlagi arhitekturnega primera gradnje hiše si lahko predstavljamo, da naročnik v svoji hiši želi odprto kuhinjo, kjer ni nobenih ovir med kuhinjo in jedilnico. Kaj pa, če sta na tem mestu potrebna steber in tram za podporo drugega nadstropja hiše? Lastnik hiše in ahitekt bosta zato morala v tej situaciji sprejeti kompromis.</p>
<p>Obstoječo zasnovo bo treba predelati, če se izkaže, da komponent, povezav in odgovornosti idejne zasnove v tehnični zasnovi ni mogoče izpeljati ali če ne izpolnjujejo zahtev. Ravno zato je nenehno preverjanje pri stranki, ali idejna zasnova zajema tisto, kar želi. Lažje je namreč izvesti preoblikovanje v fazi načrtovanja, kot pa v fazi kodiranja.</p>
<p>Večji sistemi za načrtovanje zahtevajo več časa, saj je prisotnih več komponent, povezav in odgovornosti, ki jih je treba spremljati. Ker so te komponente same po sebi velike, jih bo morda treba preoblikovati v manjše komponente, preden bo njihova zasnova dovolj podrobna.</p>
<p>Ko dosežemo izvedljiv načrt, postanejo tehnični diagrami osnova za izdelavo predvidene rešitve. Komponente na tej stopnji so lahko dovolj opredeljene, da postanejo množica funkcij, razredov in drugih komponent. Ti deli postanejo obvladljiv problem, ki ga razvijalci lahko individualno izvajajo.</p>
<p>Obstajajo številne načrtovalske tehnike, s katerimi lahko čimbolj izkoristimo proces načrtovanja in jih bomo v nadaljevanju tudi predstavili.</p>
</div>
</div>
<div id="načrtovanje-z-upoštevanjem-kakovosti" class="section level3 hasAnchor" number="16.1.3">
<h3><span class="header-section-number">16.1.3</span> Načrtovanje z upoštevanjem kakovosti<a href="P9.html#načrtovanje-z-upoštevanjem-kakovosti" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Pri razvoju programske opreme je pomemben širši pogled na doseganje željenih zahtev. V nadaljevanju si bomo pogledali, kako je trebi pri <strong>načrtovanju</strong> upoštevati in uravnotežiti različne ideje, vloge, perspektive in potencialne kompromise.</p>
<div id="kompromisi" class="section level4 hasAnchor" number="16.1.3.1">
<h4><span class="header-section-number">16.1.3.1</span> Kompromisi<a href="P9.html#kompromisi" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Pri načrtovanju včasih obstajajo določene omejitve, ki zahtevajo kompromis. Poleg programskih zahtev, ki temeljijo na željeni funkcionalnosti, obstajajo tudi <strong>atributi kakovosti</strong>, ki določajo, kako dobro mora funkcionalnost delovati. Odločitve pa lahko vključujejo kompromise pri različnih atributih kakovosti, kot so zmogljivost <em>(angl. performance)</em>, udobje <em>(angl. convenience)</em>, varnost <em>(angl. security)</em>, in te atribute je treba uravnotežiti.</p>
<p>Pomembno je npr. upoštevati, kako lahko atributi kakovosti v predlagani rešitvi v različnih situacijah medsebojno tekmujejo. Ob upoštevanju tega in tehtanju glede na zahteve izdelka, se določi ustrezen kompromis. To ravnotežje je stalnica pri <strong>arhitekturi programske opreme</strong>. Arhitekti programske opreme morajo najti najboljše ravnovesje med atributi kakovosti - pogosto tako, da ocenijo, kateri je pomembnejši. Tudi časovni roki lahko vplivajo na to, kaj je sploh izvedljivo v določenem časovnem okviru.</p>
<p>Vzemimo npr. načrtovanje vhodnih vrat v hišo. Varnost je atribut kakovosti, ki je lahko pomemben, a če na vrata dodate preveč ključavnic, jih bo morda težko enostavno odpreti in uporaba postane neprijetna. Dober načrt mora uravnotežiti varnost s priročnostjo in zmogljivostjo.</p>
</div>
<div id="kontekst-in-posledice" class="section level4 hasAnchor" number="16.1.3.2">
<h4><span class="header-section-number">16.1.3.2</span> Kontekst in posledice<a href="P9.html#kontekst-in-posledice" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p><strong>Kontekst</strong> <em>(angl. Context)</em> zagotavlja pomembne informacije pri odločanju o ravnovesju kakovosti pri načrtovanju. Npr. programska oprema, ki hrani osebne podatke, do katerih ima dostop javnost, ima lahko drugačne varnostne zahteve kot programska oprema, ki jo uporabljajo zgolj zaposleni v podjetju. Za vzpostavitev konteksta je zato pomembna komunikacija z deležniki.</p>
<p>Pri načrtovanju programske opreme moramo upoštevati tudi <strong>posledice</strong> <em>(angl. consequences)</em>. Včasih imajo načrtovalske odločitve neželjene posledice. Npr., ideja, ki se zdi primerna za majhno količino podatkov, je lahko zelo nepraktična za veliko količino podatkov.</p>
<p>Iskanje različnih pogledov na tehnično zasnovo je dobra praksa, saj s tem poskrbimo za bolj celovito implementacijo. To lahko dosežemo tako, da vprašamo za mnenje druge razvijalce ali izvedemo pregled načrta. Sistem je tudi smiselno preizkusiti, predenj ga v celoti razvijemo. Med postopkom načrtovanja lahko razvijemo prototipe alternativnih idej in z izvedbo testiranja ugotovimo, kaj deluje najbolje. Testi lahko pomagajo tudi pri odkrivanju neželjenih posledic. Npr. testiranje z majhnimi in velikimi količinami podatkov lahko v prejšnjem primeru razkrije to sistemsko omejitev.</p>
</div>
<div id="zadovoljive-lastnosti-kakovosti" class="section level4 hasAnchor" number="16.1.3.3">
<h4><span class="header-section-number">16.1.3.3</span> Zadovoljive lastnosti kakovosti<a href="P9.html#zadovoljive-lastnosti-kakovosti" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Lastnosti kakovosti dosežemo z uresničitvijo funkcionalnih in nefunkcionalnih, ki so osnova za proces načrtovanja.</p>
<p><strong>Funkcionalne zahteve</strong> <em>(angl. Functional requirements)</em> opisujejo, kaj se od sistema ali aplikacije pričakuje. Pravilnost <em>(angl. correctness)</em> je ključna kakovost, ki jo moramo doseči z izpolnitvijo funkcionalnih zahtev. Npr. če načrtujemo glasbeno aplikacijo, mora imeti aplikacija možnost prenašanja in predvajanja glasbe. Načrt mora opisati rešitev, ki pravilno izpolnjuje to zahtevo.</p>
<p><strong>Nefunkcionalne zahteve</strong> <em>(angl. Non-functional requirements)</em> določajo, kako dobro sistem oz. aplikacija izvaja svoje delo. Nefunkcionalne zahteve lahko vključujejo zmogljivost <em>(angl. performance)</em>, uporabo virov <em>(angl. resource usage)</em> in učinkovitost <em>(angl. efficiency)</em>; kar lahko tudi izmerimo v delujoči aplikaciji. Nefunkcionalne zahteve glasbene aplikacije lahko določajo prenos glasbe samo do določene omejitve pomnilnika. Druge lastnosti, povezane z nefunkcionalnimi zahtevami programske opreme, so <strong>ponovna uporaba</strong> <em>(angl. reusability)</em>, <strong>prilagodljivost</strong> <em>(angl. flexibility)</em> in <strong>vzdrževalnost</strong> <em>(angl. maintainability)</em>. Ti vidiki pomagajo pri razumevanju potencialnega nadaljnjega razvoja programske opreme in omogočanje prihodnjih sprememb.</p>
<p>Zahteve so sprva pogosto nepopolne in jih kasneje razrešimo s pomočjo interakcije z naročnikom in končnimi uporabniki.</p>
<p>Izpolnjevanje funkcionalnih in nefunkcionalnih zahtev je pomembno, vendar lahko obstaja še tudi druge pomembne omejitve, ki pripeljejo do kompromisov. Zaradi je zelo pomembna komunikacija in določitev, kaj je še sprejemljivo za deležnike. Če si pogledamo primer, kjer vsi avtomobili izpolnjujejo funkcionalno zahtevo zagotavljanja prevoza, vendar pa lahko nefunkcionalne zahteve in poudarek na določenih lastnostih kakovosti močno spremeni končni izdelek - različni pospeški, vodljivost, teža in poraba goriva lahko naredijo razliko med enoprostorcem in športnim avtomobilom.</p>
<p>Pri preverjanju zahtevanih lastnosti kakovosti načrta in implementacije moramo uporabljati preglede in testiranje. Nekatere lastnosti lahko potrdimo tudi s povratnimi informacijami od končnih uporabnikov.</p>
<p>V nadaljevanju navajamo nekaj pogostih kompromisov v zvezi s kakovostjo pri načrtovanju programske opreme:</p>
<ul>
<li>Zmogljivost <em>(angl. performance)</em> in vzdrževalnost <em>(angl. maintainability)</em>, kjer je visoko zmogljivo izvorna koda morda manj razumljiva in modularna, kar posledično povzroča težje vzdrževanje. Druga možnost je, da dodatno razvita izvorna koda za zagotavljanje združljivosti s prejšnjimi verzijami vpliva na zmogljivost in vzdržljivost.</li>
<li>Zmogljivost <em>(angl. performance)</em> in varnost <em>(angl. security)</em>, kjer lahko dodatni stroški za visoko stopnjo varnostjo zmanjšajo zmogljivost.</li>
</ul>
</div>
<div id="kompromisi-1" class="section level4 hasAnchor" number="16.1.3.4">
<h4><span class="header-section-number">16.1.3.4</span> Kompromisi<a href="P9.html#kompromisi-1" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Pri načrtovanju programske opreme je poleg uravnoteženja lastnosti kakovosti in izpolnjevanja funkcionalnih zahtev pomembno upoštevati več perspektiv. Programska oprema mora tako zadovoljiti lastnosti, ki so pomembne za uporabnike kot tudi za razvijalce. To pomeni, da organizacijska struktura programske opreme lahko vpliva na kakovost delovanja, kot jo razumejo uporabniki in na kakovost ponovne uporabe in vzdrževalnosti, kot to razumejo razvijalci.</p>
<p>Pri načrtovanju moramo ravnovesje med lastnostmi kakovosti razumeti in tudi upoštevati. Pri tem je pomembno prioritiziranje in razumevanje, katere lastnosti dejansko potrebujemo. Dobro vprašanje pri ugotavljanju potencialnih kompromisov, ki jih bomo morali sprejeti, je, ali obstaja način, da zmanjšamo določeno lastnost kakovosti z namenom da dosežemo ravnotežje z drugo.</p>
<blockquote>
<p><strong>Opomba</strong>: Pri načrtovanju programske opreme moramo predvsem upoštevati naslednje lastnosti kakovosti: <strong>zmogljivost</strong> <em>(angl. <a href="https://en.wikipedia.org/wiki/Computer_performance"><i class="fa-brands fa-wikipedia-w"></i>performance</a>)</em>, <strong>vzdrževalnost</strong> <em>(angl. <a href="https://en.wikipedia.org/wiki/Maintainability"><i class="fa-brands fa-wikipedia-w"></i>maintainability</a>)</em>, <strong>varnost</strong> <em>(angl. <a href="https://en.wikipedia.org/wiki/Computer_security"><i class="fa-brands fa-wikipedia-w"></i>security</a>)</em> in <strong>združljivost s prejšnjimi verzijami</strong> <em>(angl. <a href="https://en.wikipedia.org/wiki/Backward_compatibility"><i class="fa-brands fa-wikipedia-w"></i>backwards compatibility</a>)</em>.</p>
</blockquote>
<p>Prav tako je pomembno upoštevanje omejitve z vidika realne izvedbe projekta. Pri razvoju projekta je treba namreč uravnotežiti razpoložljive vire, stroške, čas in delovno silo.</p>
</div>
</div>
<div id="razred-odgovornost-sodelovanje" class="section level3 hasAnchor" number="16.1.4">
<h3><span class="header-section-number">16.1.4</span> Razred, odgovornost, sodelovanje<a href="P9.html#razred-odgovornost-sodelovanje" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Do tega trenutka smo si pogledali postopek pridobivanja zahtev in uporabo idejne zasnove pri zbiranju začetnih idej o tem, kako izpolniti zahteve pri razvoju programske opreme. V tej fazi se vzpostavijo komponente, povezave in odgovornosti nekaterih zahtev.</p>
<p>Preučevali smo tudi, kako komponente in povezave, v procesu tehnične zasnove z upoštevanjem lastnosti kakovosti, dopolnimo s tehničnimi podrobnostmi. To nam kasneje olajša implementacijo komponent in povezav.</p>
<p>V nadaljevanju pa si bomo pogledali pomembno tehniko, ki nam pomaga pri predstavitvi komponent, odgovornosti in povezav pri oblikovanju idejne zasnove na visoki ravni. Ta tehnika se imenuje <strong>kartice razredov, odgovornosti in sodelovanja</strong> <em>(angl. <a href="https://en.wikipedia.org/wiki/Class-responsibility-collaboration_card"><i class="fa-brands fa-wikipedia-w"></i>Class, Responsibility, Collaborator (<strong>CRC</strong>) cards</a>)</em>. Kartice CRC pomagajo pri zajemu in organizaciji komponent v razrede, prepoznavanju odgovornosti komponent in določanju njihovega medsebojnega sodelovanja. Zato tudi pomagajo pri izboljšavi komponent v okviru zasnove programske opreme.</p>
<div id="kartice-crc" class="section level4 hasAnchor" number="16.1.4.1">
<h4><span class="header-section-number">16.1.4.1</span> Kartice CRC<a href="P9.html#kartice-crc" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Med procesom idejne zasnove je komponente, poleg identifikacije komponent, odgovornosti in povezav, smiselno tudi predstaviti. Ena izmed tehnik je uporaba <strong>kartic</strong> razredov, odgovornosti in sodelovanja (<strong>CRC</strong>).</p>
<p>Kartice CRC se uporabljajo za zajem, organizacijo in izboljšanje komponent sistemskega načrta. Takšne kartice vsebujejo tri dele: na vrhu kartice je <strong>ime razreda</strong> <em>(angl. class name)</em>, na levi strani kartice je <strong>odgovornost razreda</strong> <em>(angl. class responsibilities)</em> in na desni <strong>sodelavci</strong> <em>(angl. collaborators)</em>. Tabela <a href="P9.html#tab:CRC-kartica#tab:CRC-kartica">16.1</a> prikazuje primer takšne kartice, ki je po velikosti podobna bančni kartici.</p>
<table class="tabela-manjsa table" style="width: auto !important; margin-left: auto; margin-right: auto;">
<thead>
<tr>
<th style="border-bottom:hidden;padding-bottom:0; padding-left:3px;padding-right:3px;text-align: center; " colspan="2">
<div style="border-bottom: 1px solid #ddd; padding-bottom: 5px; ">
<strong>Ime razreda</strong> <em>(angl. Class name)</em>
</div>
</th>
</tr>
</thead>
<caption>
<span id="tab:CRC-kartica">Tabela 16.1: </span>Gradniki kartice CRC
</caption>
<tbody>
<tr>
<td style="text-align:center;">
<strong>Odgovornosti</strong> <em>(angl. Responsibilities)</em>
</td>
<td style="text-align:center;">
<strong>Sodelavci</strong> <em>(angl. Collaborators)</em>
</td>
</tr>
</tbody>
</table>
<p>Če želimo zajeti kandidata za komponento s pomočjo kartice CRC, postavimo ime komponente v razdelek z imenom razreda in odgovornosti v razdelek z odgovornostmi. Povezave so zajete v razdelku s sodelavci. Povezave ali sodelovci označujejo druge razrede, s katerimi razred, ki je zapisan v razdelku imena razreda, sodeluje pri izpolnjevanju svojih odgovornosti. Ti koraki se nato iterativno ponavljajo in pri tem nastajajo nove kartice, dokler ne identificiramo vseh razredov, odgovornosti in sodelavcev sistema.</p>
<p>Pri načrtovanju sistema se kartice CRC uporabljajo z namenom, da prisilijo načrtovalce k nadaljnjemu razčlenjevanju komponent na manjše komponente in razrede, da jih je mogoče posamično opisati na kartici.</p>
</div>
<div id="izdelava-prototipov-in-simulacija" class="section level4 hasAnchor" number="16.1.4.2">
<h4><span class="header-section-number">16.1.4.2</span> Izdelava prototipov in simulacija<a href="P9.html#izdelava-prototipov-in-simulacija" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Uporaba kartic CRC je preprost pristop, ki ima številne prednosti. Je poceni, kartice lahko urejamo in pristop je široko dostopen. Kartice CRC nam pomagajo predvsem pri razvrščanju informacij v obvladljive dele.</p>
<p>Ključna prednost uporaba kartic CRC je možnost fizične reorganizacije načrta. Glede na to, da je vsaka komponenta predstavljena s kartico, lahko povezane kartice premaknemo skupaj. To nam omogoča, da raziščemo, kako bo sistem deloval in pri tem ugotovimo morebitne pomanjkljivosti načrta.</p>
<p>Eksperimentiramo lahko tudi s premikanjem kartic v različnih vrstnih redih in analiziramo posledice, kar nam omogoča pregled alternativnih predlogov načrta. To pomeni, da se lahko kartice CRC pri idejni zasnovi uporabijo tudi za prototipiranje in simulacijo sistema.</p>
<p>Modele pri načrtovanju včasih poimenujemo tudi modeli CRC. Kartice CRC je treba organizirati tako, da združimo komponente, ki testno sodelujejo. To olajša razumevanje odnosov ali povezave med razredi oz. komponentami.</p>
<p>Kartice CRC so zelo primerno orodje za sestanke skupine za razvoj programske opreme. Vse kartice lahko postavimo na mizo in omogočimo razpravo ali simulacijo z razvojno ekipo, kjer ugotavljamo, kako razredi sodelujejo z drugimi razredi pri doseganju lastnih odgovornosti. To nam omogoča, da sistem predstavimo vizualno in pridobimo povratno informacijo ostalih sodelujočih.</p>
<p>Kartice CRC imajo največjo dodano vrednosti pri izdelavi prototipov in simulacij v okviru idejnega načrta. Na voljo pa so tudi drugi načrtovalski pristopi, ki jih bomo spoznali v nadaljevanju.</p>
</div>
</div>
</div>
<div id="objektno-usmerjeno-načrtovanje" class="section level2 hasAnchor" number="16.2">
<h2><span class="header-section-number">16.2</span> Objektno usmerjeno načrtovanje<a href="P9.html#objektno-usmerjeno-načrtovanje" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Predhodno poglavje <a href="P9.html#OO-thinking">16.1.1</a> je bilo namenjeno predstavitvi pomena načrtovanja pri procesu razvoja programske opreme in se je končalo s povzetkom prednosti uporabe kartic CRC za določitev idejne zasnove.</p>
<p>To poglavje bo bolj podrobno predstavilo objektno usmerjeno načrtovanje. Začelo se bo s predstavitvijo problemov načrtovanja in kakšen je bil razvoj programskih jezikov v smeri objektne usmerjenosti. Nato bomo predstavili štiri glavna načrtovalska načela: abstrakcijo, ovijanje, razgradnjo in posploševanje. Ta načela pomagajo pri reševanju problemov in vodijo k razvoju prilagodljive programske opreme, ki jo lahko ponovno uporabimo in jo je enostavno vzdrževati. To so tudi ključna načela, ki jih moramo upoštevati pri razvoju dobrega načrta programske opreme.</p>
<p>Predstavili bomo tudi kako načrtovalsko strukturo predstavimo v obliki izvorne kode programskega jezika Java in UML razrednih diagramov z uporabo prej omenjenih načel. Nazadnje bo predstavljena tudi implementacija in dedovanje vmesnikov v okviru načrtovalskega načela posploševanja.</p>
<div id="izdelava-modelov-načrta" class="section level3 hasAnchor" number="16.2.1">
<h3><span class="header-section-number">16.2.1</span> Izdelava modelov načrta<a href="P9.html#izdelava-modelov-načrta" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Ko delamo na projektu razvoja programske opreme, je ključna, da ne začnemo takoj s pisanjem izvorne kode, kot začetni poskus reševanja težave. Namesto tega je pri izdelavi ustrezne rešitve pomembno razumevanje vseh zahtev in uporaba dobrega načrta.</p>
<p>Korak načrtovanje se nahaja med razumevanjem zahtev in izdelavo končne rešitve. Iterativno se ukvarja tako s področjem problema kot tudi rešitve. Načrt mora predstavljati in opisovati koncepte na način, da ga razumejo uporabniki in razvijalci, saj mora omogočati razpravo z uporabo skupnih izrazov.</p>
<p>Načrt je pomemben korak pri razvoju programske opreme in sčasoma so nastali števili pristopi, ki ta proces olajšajo. Npr. nekatere načrtovalske strategije in programski jeziki so nastali za rešitev posebnih vrst težav.</p>
<p>Eden od pristopov, ki olajša proces načrtovanja, je tudi objektno usmerjen pristop. Le-ta omogoča opis <strong>konceptov</strong> iz problemskega področja in rešitev z <strong>objekti</strong>, ki predstavljajo pojme, razumljive uporabnikom in razvijalcem. To skupno razumevanje omogoča uporabnikom in razvijalcem razpravo o elementih zapletenih problemov. Objektno usmerjen razvoj z objektno usmerjenimi programski jeziki je zato priljubljen pristop pri reševanju kompleksnih problemov.</p>
<p>Dober načrt ne naredi neposrednega preskoka iz koncepta v problemskem prostoru na obravnavo tega v prostoru rešitev, kar velja tudi za objektno usmerjeno načrtovanje. Kot smo že predstavili v poglavju <a href="P9.html#nacrt">16.1.2.2</a>, je objektno usmerjeno načrtovanje sestavljeno iz:</p>
<ul>
<li><strong>idejne zasnove</strong> <em>(angl. conceptual design)</em> z uporabo <strong>objektno usmerjene analize</strong> <em>(angl. object-oriented analysis)</em> pri prepoznavanju ključnih objektov in razčlenitvi problema na obvladljive dele,</li>
<li><strong>tehnične zasnove</strong> <em>(angl. technical design)</em> z uporabo <strong>objektno usmerjenega načrtovanja</strong> <em>(angl. object-oriented design)</em> pri nadaljnji opredelitvi podrobnosti objektov, vključno z njihovimi atributi in vedenjem, tako da je razvijalcem razumljivo, kaj morajo implementirati, da nastane delujoča programske rešitev.</li>
</ul>
<p>Te načrtovalske aktivnosti se izvajajo nenehno in se ponavljajo.</p>
<p>Cilj načrtovanja programske opreme je izdelava in izboljšava <strong>modelov</strong> vseh objektov programske opreme, kjer so kategorije teh objektov naslednje:</p>
<ul>
<li><strong>entitetni objekti</strong> <em>(angl. entity objects)</em>, kjer je začetni fokus pri načrtovanju v problemskem prostoru,</li>
<li><strong>kontrolni objekti</strong> <em>(angl. control objects)</em>, ki sprejemajo dogodke in usklajujejo akcije, ko se proces premika v prostor rešitve,</li>
<li><strong>mejni objekti</strong> <em>(angl. boundary objects)</em>, ki povezujejo zunanje storitve s sistemom, ko se proces premika proti prostoru rešitve.</li>
</ul>
<p>Programski modeli pomagajo pri razumevanju in organizacija procesa načrtovanja objektov. Pri kompleksnih problemih uporabljamo načrtovalska načela in smernice: poenostavitev objektov modela in razdelitev na manjše dele ter iskanje skupnih točk, ki jih lahko dosledno obravnavamo. Modele je treba nenehno vrednotiti, da se zagotovi ustrezna obravnava prvotnega problema in da zadovoljimo vse lastnosti kakovosti, kot je možnost ponovne uporabe, prilagodljivost in vzdrževalnost. Modeli se uporabljajo tudi kot projektna dokumentacija programske opreme. Modele pogosto tudi preslikamo v skelet izvorne kode, še posebej pri objektno usmerjenih jezikih, kot je npr. Java.</p>
<p>Modele programske opreme pogosto zapišemo v obliki vizualne notacije standardnega jezika za modeliranje računalniških sistemov <em>(angl. <a href="https://en.wikipedia.org/wiki/Unified_Modeling_Language"><i class="fa-brands fa-wikipedia-w"></i>Unified Modelling Language (<strong>UML</strong>)</a>)</em>. Jezik UML ima na voljo različne vrste modelov oz. diagramov UML, ki jih lahko uporabimo, ko se osredotočamo na različne vidike programske opreme. Npr. strukturni model lahko uporabimo za opis, kaj objekti počnejo in kako so povezani, kar je analogno maketi stavbe, ki se uporablja v arhitekturi.</p>
</div>
<div id="razvoj-programskih-jezikov" class="section level3 hasAnchor" number="16.2.2">
<h3><span class="header-section-number">16.2.2</span> Razvoj programskih jezikov<a href="P9.html#razvoj-programskih-jezikov" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Jezik je beseda, ki jo uporabljamo za opis sistema za medsebojno komuniciranje. Pisanje, branje, govorjenje, risanje in kretnje so del jezika. Jeziki se morajo nenehno razvijati, da ostanejo živi in jih ljudje uporabljajo.</p>
<p>Programski jeziki pri tem niso nobena izjema in tako kot tradicionalni jeziki so se skozi čas razvijali. Pogosto so se programski jeziki razvili, da bi ponudili (učinkovitejše) rešitve za težave, ki jih trenutni programski jeziki ne morejo. Za obravnavo novih podatkovnih struktur se lahko npr. tudi pojavijo novi jeziki oz. ideje. Ideje, uporabljene v programskih jezikih, so povzročile tudi večje premike <strong>paradigmah programiranja</strong> <em>(angl. <a href="https://en.wikipedia.org/wiki/Programming_paradigm"><i class="fa-brands fa-wikipedia-w"></i>programming paradigms</a>)</em>.</p>
<p>Zato je pomembno poznavanje zgodovine paradigm programiranja. Kot razvijalec programske opreme lahko še vedno naletite na sisteme, ki uporabljajo starejše jezike in načrtovalske paradigme. Čeprav je objektno usmerjeno programiranje zelo močno orodje, lahko obstajajo določeni problemi, ki jih bolje ali učinkoviteje rešiti z drugo paradigmo. Zato je tudi pomembno razumevanje zgodovine, saj novi jeziki morda ne bodo vpeljali novih struktur, ampak le spremenili obstoječe. Nekateri stari načini dela in stare paradigme so lahko tako razširjene, da je nove strukture težko prepoznati. In pri tem nam pomaga poznavanje zgodovine.</p>
<p>Tabela <a href="P9.html#tab:programski-jeziki#tab:programski-jeziki">16.2</a> povzema glavne paradigme programiranja v zgodovini programskih jezikov.</p>
<table class="tabela-manjsa">
<caption>
<span id="tab:programski-jeziki">Tabela 16.2: </span>Glavne paradigme programiranja skozi zgodovino
</caption>
<thead>
<tr>
<th style="text-align:left;">
Programski jezik
</th>
<th style="text-align:left;">
Časovno obdobje
</th>
<th style="text-align:left;">
Rešitve, ki jih ponuja programski jezik
</th>
<th style="text-align:left;">
Nerešena vprašanja programskega jezika
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;vertical-align:top;">
<strong><a href="https://en.wikipedia.org/wiki/COBOL"><span style="white-space:nowrap"><i class="fa-brands fa-wikipedia-w"></i>COBOL</span></a></strong>, <strong><a href="https://en.wikipedia.org/wiki/Fortran"><span style="white-space:nowrap"><i class="fa-brands fa-wikipedia-w"></i>Fortran</span></a></strong>
</td>
<td style="text-align:left;vertical-align:top;">
1960
</td>
<td style="text-align:left;vertical-align:top;">
<p>
COBOL in Fortran sta sledila <strong>imperativni paradigmi</strong> <em>(angl. <a href="https://en.wikipedia.org/wiki/Imperative_programming"><i class="fa-brands fa-wikipedia-w"></i>imperative paradigm</a>)</em>, kjer so večji programi razdeljeni na manjše dele, imenovane podprogrami.
</p>
<p>
Ker je bila računalniška obdelava draga, je bilo pomembno povečanje zmogljivosti obdelave. Za rešitev tega problema so se uporabili <strong>globalni podatki</strong> <em>(angl. global data)</em>, tako da so bili le-ti na voljo na enem mestu v pomnilniku računalnika in so bili programu dostopni kjerkoli. To je pomenilo, da so morali podprogrami za dostop do spremenljik le na eno mesto.
</p>
<p>
<img src="assets/img/Paradigma_1.png" />
</p>
</td>
<td style="text-align:left;vertical-align:top;">
Ob spremembi podatkov se lahko zgodi, da podprogrami dostopajo do globalnih podatkov, ki niso takšni, kot pričakujejo. Da bi se temu izognili, potrebujemo boljše upravljanje s podatki.
</td>
</tr>
<tr>
<td style="text-align:left;vertical-align:top;">
<strong><a href="https://en.wikipedia.org/wiki/ALGOL_68"><span style="white-space:nowrap"><i class="fa-brands fa-wikipedia-w"></i>Algol 68</span></a></strong>, <strong><a href="https://en.wikipedia.org/wiki/Pascal_(programming_language)"><span style="white-space:nowrap"><i class="fa-brands fa-wikipedia-w"></i>Pascal</span></a></strong>
</td>
<td style="text-align:left;vertical-align:top;">
zgodnja 1970
</td>
<td style="text-align:left;vertical-align:top;">
<p>
V obdobju 1960 so se uporabljali globalni podatki, vendar lahko poljubne spremembe podatkov povzročijo težave za podprograme.
</p>
<p>
Rešitev predstavlja vpeljava obsega <em>(angl. scope)</em> in <strong>lokalnih spremenljivk</strong> <em>(angl. <a href="https://en.wikipedia.org/wiki/Local_variable"><span class="skupaj"><i class="fa-brands fa-wikipedia-w"></i>local variables</span></a>)</em> - podprogrami oz. procedure so lahko imeli vsaka svoje spremenljivke.
</p>
<p>
<img src="assets/img/Paradigma_2.png" />
</p>
<p>
Ti jeziki podpirajo uporabo <strong>abstraktnega podatkovnega tipa</strong> <em>(angl. abstract data type)</em>, ki ga določi programer in ni prvotno del programskega jezika. Gre za skupino povezanih informacij, ki so označeni s <strong>tipom</strong> <em>(angl. type)</em>.
</p>
<p>
Ker so podatki združeni in posredovani v različne procedure z uporabo podatkovnih tipov, to pomeni, da je procedura edina, ki lahko spreminja del podatkov. Ni nam več treba skrbeti, da bi podatke spreminjala kakšna druga procedura.
</p>
</td>
<td style="text-align:left;vertical-align:top;">
Proti sredini 1970 je računalniška obdelava postala cenejša. Hkrati je človeško delo postalo dražje in na ta način predstavljajo ozko grlo pri razvoju programske opreme. Napredek pri računalniški obdelavi je omogočil, da so računalniki začeli z obdelavo bolj zahtevnih problemov. To pa je tudi pomenilo, da se je programska oprema hitro povečala in vzdrževanje ene datoteke je bilo zelo zahtevno.
</td>
</tr>
<tr>
<td style="text-align:left;vertical-align:top;">
<strong><a href="https://en.wikipedia.org/wiki/C_(programming_language)"><i class="fa-brands fa-wikipedia-w"></i>C</a></strong>, <strong><a href="https://en.wikipedia.org/wiki/Modula-2"><span style="white-space:nowrap"><i class="fa-brands fa-wikipedia-w"></i>Modula-2</span></a></strong>
</td>
<td style="text-align:left;vertical-align:top;">
sredina 1970
</td>
<td style="text-align:left;vertical-align:top;">
<p>
Do sredine 1970 so računalniški postali hitrejši in so bili sposobni obdelati bolj kompleksne probleme. Vendar je to pomenilo, da so starejši programi hitro postali preveliki za vzdrževanje. To je vodilo do novih jezikov, ki so omogočali organizacijo programov v ločenih datotekah, tako da so lahko razvijalci bolj enostavno uporabili več enoličnih kopij abstraktnih podatkovnih tipov.
</p>
<p>
</p>
<p>
<img src="assets/img/Paradigma_3.png" />
</p>
<p>
V programskem jeziku C je npr. vsaka datoteka vsebovala vse povezane podatke in funkcije, ki so z njimi manipulirale. Deklaracija do česa je mogoče dostopati, je bilo opredeljeno v <strong>naslovni datoteki</strong> <em>(angl. header file)</em>.
</p>
</td>
<td style="text-align:left;vertical-align:top;">
Dedovanje abstraktnih tipov v teh jezikih ni enostavno izvedljivo. To pomeni, da smo lahko opredelili številne podatkovne tipe, vendar ni bilo mogoče zahtevati, da je en tip razširitev drugega.
</td>
</tr>
<tr>
<td style="text-align:left;vertical-align:top;">
<strong>Objektno usmerjeni</strong> programski jeziki <a href="https://en.wikipedia.org/wiki/Java_(programming_language)"><span style="white-space:nowrap">(<i class="fa-brands fa-wikipedia-w"></i><strong>Java</strong></span></a>, <a href="https://en.wikipedia.org/wiki/C%2B%2B"><span style="white-space:nowrap"><i class="fa-brands fa-wikipedia-w"></i><strong>C++</strong></span></a>, <a href="https://en.wikipedia.org/wiki/C_Sharp_(programming_language)"><span style="white-space:nowrap"><i class="fa-brands fa-wikipedia-w"></i><strong>C#</strong></span></a> idr.)
</td>
<td style="text-align:left;vertical-align:top;">
od 1980 do sedaj
</td>
<td style="text-align:left;vertical-align:top;">
<p>
Čeprav je bilo programe lažje upravljati preko abstraktnih tipov, še vedno ni bilo možnosti dedovanja le-teh. Koncepti objektno usmerjenega načrtovanja so zato postali priljubljeni načini rešitve te težave.
</p>
<p>
Cilji objektno usmerjenega načrtovanja:
</p>
<ul>
<li>
olajšava uporabe abstraktnega podatkovnega tipa,
</li>
<li>
strukturiranje sistema okrog abstraktnih tipov, ki jih imenujemo razredi,
</li>
<li>
vpeljava možnosti razširitve podatkovnega tipa v obliki dedovanja.
</li>
</ul>
<p>
</p>
<p>
<img src="assets/img/Paradigma_4.png" />
</p>
<p>
V tej paradigmi so sistemi lahko zgrajeni iz popolnoma abstraktnih podatkovnih tipov. Sistemu to omogoča posnemanje strukture problema - sistem lahko natančneje predstavlja objekte resničnega sveta.
</p>
<p>
Datoteke z definicijo razreda v objektno usmerjenem programiranju nadomeščajo datoteke v C in Modula-2. Vsak razred definira tip s povezanimi podatki in funkcijami (metodami). Razred deluje kot tovarna, ki izdeluje posamezne objekte določene vrste. To omogoča, da se podatki razdelijo v lastne ločene razrede.
</p>
</td>
<td style="text-align:left;vertical-align:top;">
Objektno usmerjeno programiranje je sedaj prevladujoča <strong>paradigma programiranja</strong>.
</td>
</tr>
</tbody>
</table>
</div>
<div id="stiri-nacrtovalska-nacela" class="section level3 hasAnchor" number="16.2.3">
<h3><span class="header-section-number">16.2.3</span> Štiri načrtovalska načela<a href="P9.html#stiri-nacrtovalska-nacela" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Objektno usmerjeno načrtovanje omogoča pripravo modelov, kjer za predstavitev sistema uporabimo objekte. Če želimo razviti objektno usmerjen program, je treba poznati ključna načrtovalska načela takšnih programov. Štiri najpomembnejša načela so: <strong>abstrakcija</strong> <em>(angl. <a href="https://en.wikipedia.org/wiki/Abstraction_(computer_science)"><span style="white-space:nowrap"><i class="fa-brands fa-wikipedia-w"></i>abstraction</span></a>)</em>, <strong>ovijanje</strong> <em>(angl. <a href="https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)"><span style="white-space:nowrap"><i class="fa-brands fa-wikipedia-w"></i>encapsulation</span></a>)</em>, <strong>razgradnja</strong> <em>(angl. <a href="https://en.wikipedia.org/wiki/Decomposition_(computer_science)"><span style="white-space:nowrap"><i class="fa-brands fa-wikipedia-w"></i>decomposition</span></a>)</em> in <strong>posploševanje</strong> <em>(angl. <a href="https://en.wikipedia.org/wiki/Generalization"><span style="white-space:nowrap"><i class="fa-brands fa-wikipedia-w"></i>generalization</span></a>)</em>.</p>
<div id="abstrakcija" class="section level4 hasAnchor" number="16.2.3.1">
<h4><span class="header-section-number">16.2.3.1</span> Abstrakcija<a href="P9.html#abstrakcija" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p><strong>Abstrakcija</strong> <em>(angl. <a href="https://en.wikipedia.org/wiki/Abstraction_(computer_science)"><span style="white-space:nowrap"><i class="fa-brands fa-wikipedia-w"></i>Abstraction</span></a>)</em> je eden glavnih načinov, kako se ljudje spopadamo s kompleksnostjo. Gre za idejo poenostavitve koncepta v problemski domeni. Abstrakcija razdeli koncept na poenostavljen opis, ki ignorira nepomembne podrobnosti in v nekem kontekstu poudari bistvene elemente, potrebne za ta koncept.</p>
<p>Abstrakcija mora slediti pravilu <strong>najmanjšega presenečenja</strong> <em>(angl. <a href="https://en.wikipedia.org/wiki/Principle_of_least_astonishment"><i class="fa-brands fa-wikipedia-w"></i>rule of least astonishment</a>)</em>. To pravilo nakazuje, da morajo biti ključni atributi in vedenja zajeta brez presenečenj ter ni definicij, ki presegajo zahtevan obseg. S tem preprečimo, da bi nepomembne lastnosti postale del abstrakcije, in zagotavlja, da je abstrakcija smiselna.</p>
<p>Elementi programa so funkcije, razredi, naštevanja in metode. Pri objektno usmerjenem načrtovanju se abstrakcija najbolj neposredno nanaša na pojem razreda. Če za določanje bistvenih podrobnosti koncepta uporabimo abstrakcijo, so te podrobnosti definirane v razredu. Vsak objekt, ki ga kreiramo iz razreda, ima bistvene podrobnosti, ki predstavljajo primerek nekega koncepta, lahko pa ima poleg tega tudi nekaj individualnih lasnosti. Poglejmo primer modelčka za piškote, ki se uporablja za medenjake. Vsa primerek piškota spada v razred medenjakov in ima enake ključne lastnosti, kot so glava, roke in noge, tudi če so potem okrašeni drugače.</p>
<p>Pri oblikovanju abstrakcije je ključen kontekst oz. določena perspektiva, saj lahko kontekst spremeni bistvene lastnosti koncepta. Npr. če pogledamo bistvene lastnosti koncepta oseba. To lahko težko razumemo, če nimamo konteksta, saj je ta koncept nejasen, ker ne poznamo namena osebe. V računalniški igri bi bile bistvene lastnosti osebe v kontekstu igralca. Po drugi strani pa bi bile v aplikaciji za športno vadbo lastnosti osebe v kontekstu športnika. Naloga načrtovalca je, da izbere ustrrzen kontekst razvoja programske opreme in ta kontekst je treba razumeti, preden se lotimo abstrakcije.</p>
<p>Bistvene lastnosti abstrakcije si lahko predstavljamo na dva načina: prreko osnovnih <strong>atributov</strong> in preko osnovnih <strong>vedenj</strong> oz. <strong>odgovornosti</strong>.</p>
<p>Osnovni atributi so lastnosti, ki sčasoma ne izginejo. Čeprave se lahko njihove vrednosti spremenijo, se atributi sami ne. Npr. koncept živali leva ima lahko atribut starost. Ta vrednost se lahko spreminja, vendar bo imel lev vedno atribut starosti.</p>
<p>Poleg osnovnih atributov abstrakcija opisuje tudi osnovno vedenje koncepta. Lev ima lahko vedenje, kot je lov, prehranjevanje in spanje. To so tudi odgovornosti, ki jih abstrakcija leva opravlja za namen življenja.</p>
<p>Abstrakcija bi torej morala opredeliti le bistvene lastnosti in vedenje koncepta. Kontekst nam pomaga določiti, kaj je dejansko pomembno. Npr. ko razmišljamo o levu v lovskem okolju, ni potrebno upoštevati, v kakšnem položaju lev najraje spi. Če se kontekst spremeni, se lahko spremeni tudi abstrakcija.</p>
<p>Načelo abstrakcije prinaša številne prednosti. Pomaga nam poenostaviti zasnovo razredov, tako da je le-ta bolj osredotočena, jedrnata in razumljiva ostalim, ki jo obravnavajo. Ker so abstrakcije močno odvisne od konteksta oz. perpsektive, je pomemben natančen razmislek, kaj je pomembno. Če se npr. spremeni namen sistema, ki ga gradimo, ali če se spremeni problem, ki ga rešujemo, moramo ponovno pregledati abstrakcije in jih ustrezno posodobiti.</p>
</div>
<div id="ovijanje" class="section level4 hasAnchor" number="16.2.3.2">
<h4><span class="header-section-number">16.2.3.2</span> Ovijanje<a href="P9.html#ovijanje" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p><strong>Ovijanje</strong> <em>(angl. <a href="https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)"><span style="white-space:nowrap"><i class="fa-brands fa-wikipedia-w"></i>Encapsulation</span></a>)</em> predstavlja koncept, ki določa, da so v kapsuli elementi, do katerih lahko dostopate od zunaj ter določeni elementi, do katerih ne morete.</p>
<p>Z ovijanjem so povezane naslednje ideje:</p>
<ul>
<li>sposobnost združevanja vrednosti atributov (ali <strong>podatkov</strong>) in vedenj (ali <strong>funkcij</strong>), ki s temi vrednostmi manipulirajo, v samostojen objekt,</li>
<li>sposobnost razkritja določenih podatkov ali funkcij tega objekta, do katerih lahko dostopamo iz drugih objektov, običajno preko <strong>vmesnika</strong> <em>(angl. interface)</em>,</li>
<li>sposobnost omejitve dostopa do določenih podatkov in funkcij samo znotraj objekta.</li>
</ul>
<p>Združevanje se pojavi naravno, ko razred definiramo za <strong>tip</strong> objekta. Načelo abstrakcije nam pomaga določiti, kateri atributi in vedenja so pomembni za koncept v določenem kontekstu. Z načelom ovijanja naredimo še korak naprej, saj zagotavlja, da so lastnosti združene v istem razredu.</p>
<p>Ovijanje nam omogoča, da imajo različni objekti, ki so nastali iz določenega razreda, lastne vrednosti podatkov posameznih atributov in posledično izkazujejo delovanje. To močno olajša programiranje, saj se podatki in koda, ki manipulira s temi podatki, nahajajo na istem mestu.</p>
<p>Podatki o objektu morajo vključevati samo tisto, kar je za objekt pomembno. Npr. objekt lev “ve”, kakšne živali lev lovi, ne ve pa, katere živali živijo na drugem kontinentu, ker to ni pomemben podatke. Razred torej ve le, kateri atributi oz. podatki so zanj pomembni.</p>
<p>Razred prav tako opredeli vedenje preko metod. Metode manipulirajo z vrednostmi atributov ali podatki v objektu, da dosežejo dejansko delovanje. Določene metode lahko izpostavimo oz. jih naredimo dostopne objektom drugih razredov. To zagotavlja vmesnik drugim objektom pri uporabi tega razreda.</p>
<div id="celovitost-in-varnost" class="section level5 hasAnchor" number="16.2.3.2.1">
<h5><span class="header-section-number">16.2.3.2.1</span> Celovitost in varnost<a href="P9.html#celovitost-in-varnost" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>Ker je ena od idej ovijanja omejevanje dostopa do določenih podatkov in funkcij na le notranjost objekta, to seveda povezuje ovijanje s <strong>celovitostjo podatkov</strong> in varnostjo občutljivih podatkov.</p>
<p>Če je zunanji dostop do določenih atributov in metod omejen, in omogoče zgolj preko posebnih metod, podatkov ni mogoče spremeniti z dodelitvijo vrednosti spremenljivkam. To preprečuje kršitev odvisnosti podatkov v objektu.</p>
<p>Podobna omejitev dostopa preprečuje tudi razkritje občutljivih informacij, tudi pri poizvedbah, ki se zanašajo na občutljive podatke.</p>
</div>
<div id="sprememba-implementacije" class="section level5 hasAnchor" number="16.2.3.2.2">
<h5><span class="header-section-number">16.2.3.2.2</span> Sprememba implementacije<a href="P9.html#sprememba-implementacije" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>Ovijanje je tudi uporabno načelo za izvajanje sprememb programske opreme. Ker je zmožnost razkrivanja podatkov ločena od množice atributov, to pomeni, da se lahko implementacija atributov in metod spremeni, vmesnik za dostop do razreda pa ostane enak. Uporabnikom, ki dostopajo do razreda ali povprašujejo po njem, ni treba skrbeti, kako implementacija za vmesnikom deluje - še vedno bodo uporabljali isti način za dostop do informacij.</p>
</div>
<div id="črna-škatla" class="section level5 hasAnchor" number="16.2.3.2.3">
<h5><span class="header-section-number">16.2.3.2.3</span> Črna škatla<a href="P9.html#črna-škatla" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>Idejo ovijanja, ki podpira spremembo implementacije, si lahko predstavljamo kot <strong>črno škatlo</strong> <em>(angl. black box)</em>. Nobenemu drugemu razredu ni treba poznati podrobnosti izvajanja znotraj razreda, če lahko dostopajo do vmesnika. Razred je torej kot črna škatla, kjer ne vidimo podrobnosti o načinu predstavitve atributov oz. kako metode izračunajo rezultate. Kaj se zgodi v škatli, da se doseže določeno vedenje, ni pomembno, dokler lahko zagotovimo vhode in pridobimo izhode s klici metod.</p>
<p>Ovijanje preseže abstrakcijsko oviro z uporabo ideje črne škatle, kjer notranje delovanje ni pomembno za zunanje okolje. Posledica tega je abstrakcija, ki uporabnikom razreda zmanjša kompleknost.</p>
<p>Ovijanje, zaradi ideje črne škatle, prav tako poveča možnost ponovne uporabe. Drug razred mora, za dosego določenega vedenja, poznati zgolj pravo metodo za klic, argumente, ki jih mora podati na vhodu in kaj pričakuje na izhodu. Enkapsulacija tako programsko opremo ohrranja modularno in enostavno za uporabo. Razrede uporablja na preprost način, saj njihovo notranje vedenje ni pomembno za druge razrede, če le obstaja vmesnik, ki jih povezuje.</p>
</div>
</div>
<div id="razgradnja" class="section level4 hasAnchor" number="16.2.3.3">
<h4><span class="header-section-number">16.2.3.3</span> Razgradnja<a href="P9.html#razgradnja" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p><strong>Razgradnja</strong> <em>(angl. <a href="https://en.wikipedia.org/wiki/Decomposition_(computer_science)"><span style="white-space:nowrap"><i class="fa-brands fa-wikipedia-w"></i>Decomposition</span></a>)</em> temelji na ideji, kjer vzamemo <strong>celoto</strong> in jo razdelimo na <strong>več delov</strong>. Drug pogled na razgradnjo pa lahko tudi pomeni, da vzamemo posamezne dele z različnimi funkcionalnostmi in jih združimo v celoto. Razgradnja omogoča, da se problemi razdelijo na manjše dele, ki jih je lažje razumeti in rešiti.</p>
<p>Pri razgradnji najprej preučimo različne odgovornosti celote in ocenimo, kako bi lahko celoto razdelili na dele, od katerih bi imel vsak svojo odgovornost. Vsak od teh delov je dejansko ločen objekt, ki ga lahko kreiramo iz ločenih razredov v našem načrtu. Na ta način je razgradnja podobna abstrakciji, kjer delimo celoto na objekte z bistvenimi lastnostmi.</p>
<p>Vsak drugačen del v okviru celote lahko zajamemo v razredu, tako da lahko dele ohranimo bolje organizirane in ovite. Razred za celoten objekt se nato nanaša na razrede za objekte, ki ga sestavljajo.</p>
<div id="narava-delov" class="section level5 hasAnchor" number="16.2.3.3.1">
<h5><span class="header-section-number">16.2.3.3.1</span> Narava delov<a href="P9.html#narava-delov" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>Celota ima lahko določeno ali dinamično število delov posamezne vrste. Če obstaja določeno število, bo imel celoten predmet v življenjski dobi točno določeno delov. Npr. primer pečice s štirimi gorilniki, kjer je število gorilnikov določeno za objekt pečice. Po drugi strani pa imamo lahko dinamično število delov. To pomeni, da lahko celoten objekt v svoji življenjski dobi pridobi nove primerke teh delnih objektov. Npr. hrana znotraj objekta hladilnika - le-ta se lahko spreminja dnevno.</p>
<p>Upoštevati tudi moramo, da lahko del služi tudi kot celota, ki je nadaljnje sestavljena. Npr. kuhinja je del hiše, kjer pa lahko tudi kuhinjo sestavljata npr. pečica in hladilnik.</p>
<p>Pri razgradnji je potrebno omeniti tudi življenjsko dobo, ki jo imajo celi in delni objekti. Včasih so te življenjske dobe tesno povezane, kjer ima del isto življenjsko dobo kot celoto - eno ne more obstajati brez drugega. Če npr. merilnik temperature pri hladilnik preneha z delovanjem, bo tudi hladilnik prenehal delovati. V drugem primeru pa, če se določena hrana v hladilniku pokvari, bo hladilnik še vedno deloval naprej.</p>
<p>Celote lahko vsebujejo tudi dele, ki si jih hkrati delijo z drugo celoto. Včasih pa tudi delitev ni mogoča ali načrtovana.</p>
</div>
</div>
<div id="posploševanje" class="section level4 hasAnchor" number="16.2.3.4">
<h4><span class="header-section-number">16.2.3.4</span> Posploševanje<a href="P9.html#posploševanje" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p><strong>Posploševanje</strong> <em>(angl. <a href="https://en.wikipedia.org/wiki/Generalization"><span style="white-space:nowrap"><i class="fa-brands fa-wikipedia-w"></i>Generalization</span></a>)</em> nam pomaga zmanjšati redundanco pri reševanju problemov. To je splošno načelo, ki se uporablja v mnogih disciplinah tudi zunaj razvoja programske opreme.</p>
<p>Pri kodiranju algoritmično vedenje pogosto modeliramo z <strong>metodami</strong>, ki omogočajo programerju posplošitev vedenja, tako da se lahko vedenje uporabi za različne vhodne podatke. Ta splošnost v okviru celotnega programa zmanjšuje potrebo po enaki kodi.</p>
<p>Pri objektno usmerjenem načrtovanju je generalizacija glavno načelo načrtovanja, vendar poleg uporabe metod, ki jih lahko uporabimo za različne podatke, objektno usmerjeno načrtovanje posplošitev doseže tudi s pomočjo <strong>dedovanja</strong> <em>(angl. <a href="https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)"><i class="fa-brands fa-wikipedia-w"></i>inheritance</a>)</em>.</p>
<p>To je mogoče z uporabo dveh vrst razredov: nadrejeni razred <em>(angl. parent class)</em> in podrejeni razred <em>(angl. child class)</em>. Podrejeni razredi podedujejo atribute in vedenje nadrejenih razredov. To pomeni, da gredo ponavljajoče, skupne lastnosti v nadrejene razrede. Nadrejeni razredi opredeljujejo <strong>splošne ideje</strong> in imajo na splošno širšo uporabo.</p>
<p>Možno je tudi, da več podrejenih razredov deduje od enega nadrejenega razreda. Vsi ti razredi prejmejo skupne atribute in vedenje, čeprav je verjetno, da bo imel vsak podrejeni razred dodatne atribute in vedenja, ki jim bodo omogočili večjo <strong>specializacijo</strong> za to, kar počnejo.</p>
<p>V standardni terminologiji je nadrejeni razred znan kot <strong>nadrazred</strong> <em>(angl. superclass)</em>, podrejeni razred pa <strong>podrazred</strong> <em>(angl. subclass)</em>. Dedovanje tako omogoča nadrazredu, da tvori posplošitev in da so njegovi podrazredi bolj specializirani.</p>
<p>Nadrazredi prihranijo čas in preprečijo napake, zlasti če se uporabijo za več podrejenih razredov. Brez nadrejenih razredo sistemi niso prilagodljivi, ponovno uporabni oz. jih je težje vzdrževati.</p>
<blockquote>
<p><strong>Opomba</strong>: Čeprav lahko razrede poimenuje poljubno, je dobra praksa pri poimenovanju nadrazredov in podrazredo takšna, da jih poimenujemo po stvareh, ki jih želimo modelirati, saj to olajša razumevanje kode.</p>
</blockquote>
<p>Posploševanje je velika dodana vrednost objektno usmerjenega načrtovanja. Ker podrazredi podedujejo atribute in vedenja nadrazredov, to pomeni, da je treba vse spremembe kode, ki je skupna obema podrazredoma, narediti zgolj enkrat v nadrazredu. To pomeni, da je spremembe programske opreme lažje izvajati in vzdrževati. Druga prednost je enostavno dodajanja podrazredov, brez da bi morali znova ustvari vse skupne atribute in vedenja zanje, zato je programsko opremo tudi lažje razširiti. Posploševanje zagotavlja robustnejšo programsko rešitev in omgoča večji delež izvorne kode, ki jo lahko ponovno uporabimo, ker lahko iste dele kode uporabimo za različne razrede.</p>
<blockquote>
<p><strong>Opomba</strong>: Obe metodi in dedovanje ponazarjata načrtovalsko načelo preko pravila <strong>“ne ponavljaj se”</strong> <em>(angl. <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself"><i class="fa-brands fa-wikipedia-w"></i>Don’t Repeat Yourself (<strong>D.R.Y.</strong>)</a>)</em>. Metode in dedovanje omogoča razvijalcem ponovno uporabo kode, kar posledično prinaša manj kode in na splošno manj ponavljanja.</p>
</blockquote>
</div>
</div>
<div id="načrtovalska-struktura-v-programskem-jeziku-java-in-uml-razrednih-diagramih" class="section level3 hasAnchor" number="16.2.4">
<h3><span class="header-section-number">16.2.4</span> Načrtovalska struktura v programskem jeziku Java in UML razrednih diagramih<a href="P9.html#načrtovalska-struktura-v-programskem-jeziku-java-in-uml-razrednih-diagramih" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Proces načrtovanja je sestavljen iz idejne in tehnične zasnove. Idejna zasnova, vključno z izdelavo prototipov in simulacijami idej na višji ravni je izvedljiva s pomočjo kartic CRC. Kartice CRC olajšajo komunikacijo z naročnikom in razvojni ekipi omogočajo kreiranje načrtov, brez da bi se ukvarjali z izvorno kodo. Vendar pa je pri tehnični zasnovi potrebno bolj napredna tehnika, s katero lahko razvijalcem jasno sporočimo potrebe. Ena od takšnih tehnik, ki se uporablja za tehnično načrtovanje, je <strong>UML razredni diagram</strong> <em>(angl. <a href="https://en.wikipedia.org/wiki/Class_diagram"><i class="fa-brands fa-wikipedia-w"></i>UML Class Diagram</a>)</em> oz. preprosto razredni diagram. Ti diagrami zagotavljajo več podrobnosti kot kartice CRC in omogočajo lažjo pretvorbo v razrede pri implementaciji.</p>
<p>V nadaljevanju bomo pogledali, kako lahko z UML razrednimi diagrami in programskim jezikom Java obvladujemo ključna načrtovalska načela: abstrakcija, ovijanje, razgradnja in posploševanje.</p>
<div id="abstrakcija-1" class="section level4 hasAnchor" number="16.2.4.1">
<h4><span class="header-section-number">16.2.4.1</span> Abstrakcija<a href="P9.html#abstrakcija-1" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Načrtovalsko načelo abstrakcije omogoča poenostavitev koncepta na njegove bistvene elemente v določenem kontekstu. Abstrakcijo lahko uporabimo na ravni načrtovanja z uporabo UML razrednih diagramov, kjer se načrt na koncu spremeni v kodo.</p>
<p>Kartice CRC pri načrtovanju sistemov zajamejo komponente, ki jih lahko sčasoma izboljšamo v funkcije, razrede ali zbirke drugih komponent.</p>
<p>Poglejmo si na primeru, kako se kartica CRC preslika v razredni diagram. V tabeli <a href="P9.html#tab:CRC-kartica-zivila#tab:CRC-kartica-zivila">16.3</a> je primer kartice CRC, ki predstavlja povzetek živila v kontekstu trgovine z živili.</p>
<table class="tabela-manjsa table" style="width: auto !important; margin-left: auto; margin-right: auto;">
<thead>
<tr>
<th style="border-bottom:hidden;padding-bottom:0; padding-left:3px;padding-right:3px;text-align: center; " colspan="2">
<div style="border-bottom: 1px solid #ddd; padding-bottom: 5px; ">
<strong>Živilo</strong>
</div>
</th>
</tr>
</thead>
<caption>
<span id="tab:CRC-kartica-zivila">Tabela 16.3: </span>Kartica CRC za živilo
</caption>
<tbody>
<tr>
<td style="text-align:left;">
Poznavanje <strong>ID-ja živila</strong><br>Poznavanje <strong>imena</strong><br>Poznavanje <strong>proizvajalca</strong><br>Poznavanja <strong>datuma poteka</strong><br>Poznavanje <strong>cene</strong><br>Preverjanje, če je <strong>znižana cena</strong>
</td>
<td style="text-align:left;">
</td>
</tr>
</tbody>
</table>
<p>Na sliki <a href="P9.html#fig:RD-zivila#fig:RD-zivila">16.2</a> je isti koncept predstavljen v obliki razrednega diagrama.</p>

<div class="figure" style="text-align: center"><span style="display:block;" id="fig:RD-zivila"></span>
<img src="https://teaching.lavbic.net/plantuml/svg/JOynQyD038Nt-nM2BksGiL0ynccXMw5RDlbETHIVfQ2J4t38V-_5XZQBqFiaFVJAm792mn5YnbBW6W0wZ4DlEabgDQl1vS1ETwwMo5RszFgnVNjlAqKplQomo_Kot4BvC_stYik66qgf8n8FcNuSNC6uFpWaDehEAY6id-pvp5cNX-Qb_TmryEt6qbV48pseaodFPpnYflY04_eqVgdJW0tiS0aHIQf8EdNvBZURMewq5vvHiAt3vvUc9jLCAE7s2m00" alt="Razredni diagram za živila PlantUML" width="170" />
<p class="caption">
Slika 16.2: Razredni diagram za živila <a href="https://teaching.lavbic.net/plantuml/uml/JOynQyD038Nt-nM2BksGiL0ynccXMw5RDlbETHIVfQ2J4t38V-_5XZQBqFiaFVJAm792mn5YnbBW6W0wZ4DlEabgDQl1vS1ETwwMo5RszFgnVNjlAqKplQomo_Kot4BvC_stYik66qgf8n8FcNuSNC6uFpWaDehEAY6id-pvp5cNX-Qb_TmryEt6qbV48pseaodFPpnYflY04_eqVgdJW0tiS0aHIQf8EdNvBZURMewq5vvHiAt3vvUc9jLCAE7s2m00"><small><i class='fas fa-project-diagram' style='padding-right:4px'></i>PlantUML</small></a>
</p>
</div>
<p>Vsak koncept ali razred v razrednem diagramu je predstavljen s pravokotnikom, kot je prikazano na sliki <a href="P9.html#fig:RD-predloga#fig:RD-predloga">16.3</a>, kjer so trije razdelki:</p>
<ul>
<li><p><strong>ime razreda</strong> je enako imenu razreda v programskem jeziku Java,</p></li>
<li><p>razdelek z <strong>atributi</strong> predstavlja spremenljivke v programskem jeziku Java in opredeljuje atribute abstrakcije z uporabo standardne predloge za ime spremenljivke in njenim tipom (razred ali osnovni),</p>
<p><code>&lt;ime spremenljivke&gt;: &lt;tip spremenljivke&gt;</code></p></li>
<li><p>razdelek z <strong>operacijami</strong> je enakovreden metodam v programskem jeziku Java in opredeljuje vedenje abstrakcije z uporabo standardne predloge.</p>
<p><code>&lt;ime&gt; ( &lt;seznam parametrov&gt; ) : &lt;tip odgovora&gt;</code></p></li>
</ul>

<div class="figure" style="text-align: center"><span style="display:block;" id="fig:RD-predloga"></span>
<img src="../../plantuml/svg/HOx12i9034Jl-OgWvnu5hreKFFaDwMviOxUx9PjIKFhlRYtePSYy9CFaNk98IWEwG3dZ6n0RSdshQOg-JY4fpfqOhpofPztO_d0z7ozreQIQvWqseNp20laN-ezotmjJYhciE1e4VXXQGfMsC_IYx4nI1DYQxF0sC2gzb3qLjpOxcKepcPIngehSHrPoycHOFW00" alt="Razredni diagram za živila PlantUML" width="130" />
<p class="caption">
Slika 16.3: Razredni diagram za živila <a href="https://teaching.lavbic.net/plantuml/uml/HOx12i9034Jl-OgWvnu5hreKFFaDwMviOxUx9PjIKFhlRYtePSYy9CFaNk98IWEwG3dZ6n0RSdshQOg-JY4fpfqOhpofPztO_d0z7ozreQIQvWqseNp20laN-ezotmjJYhciE1e4VXXQGfMsC_IYx4nI1DYQxF0sC2gzb3qLjpOxcKepcPIngehSHrPoycHOFW00"><small><i class='fas fa-project-diagram' style='padding-right:4px'></i>PlantUML</small></a>
</p>
</div>
<p>V primeru na sliki <a href="P9.html#fig:RD-zivila#fig:RD-zivila">16.2</a> imamo na voljo vedenje, kjer živila vračajo podatke ali obstaja znižana cena. Ta metoda se imenuje <code>jeZnizanaCena</code> in vrača logično vrednost <code>boolean</code>, če je na voljo akcijska cena. Omenjena metoda ne vsebuje nobenega parametra, zato le-ta tudi ni vključen.</p>
<p>Če bi dodali parameter, npr. datum, bi sledili predlogi abstrakcije in metodo bi zapisali v obliki <code>jeZnizanaCena(datum: Date) : boolean</code>.</p>
<p>Opazimo lahko, da razredni diagrami razlikujejo med odgovornostmi, ki postanejo lastnosti in operacije, medtem ko jih pri karticah CRC navajamo skupaj. S pomočjo tega pristopa zmanjšamo dvoumnost in zato je tudi razredne diagrame lažje preslikati v izvorno kodo.</p>
<p>Če nadaljujemo naš primer z živili, lahko opazimo, da je preslikava razrednega diagram v izvorno kodo v programskem jeziku Java, zelo enostavna.</p>
<p><code>Zivilo.java</code></p>
<div class="sourceCode" id="Zivilo"><pre class="sourceCode java"><code class="sourceCode java"><span id="Zivilo-1"><a href="P9.html#Zivilo-1" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> Zivilo <span class="op">{</span></span>
<span id="Zivilo-2"><a href="P9.html#Zivilo-2" tabindex="-1"></a>  publid <span class="bu">String</span> ziviloId<span class="op">;</span></span>
<span id="Zivilo-3"><a href="P9.html#Zivilo-3" tabindex="-1"></a>  <span class="kw">public</span> <span class="bu">String</span> ime<span class="op">;</span></span>
<span id="Zivilo-4"><a href="P9.html#Zivilo-4" tabindex="-1"></a>  <span class="kw">public</span> <span class="bu">String</span> proizvajalec<span class="op">;</span></span>
<span id="Zivilo-5"><a href="P9.html#Zivilo-5" tabindex="-1"></a>  <span class="kw">public</span> <span class="bu">Date</span> datumPoteka<span class="op">;</span></span>
<span id="Zivilo-6"><a href="P9.html#Zivilo-6" tabindex="-1"></a>  <span class="kw">public</span> <span class="dt">double</span> cena<span class="op">:</span></span>
<span id="Zivilo-7"><a href="P9.html#Zivilo-7" tabindex="-1"></a>  </span>
<span id="Zivilo-8"><a href="P9.html#Zivilo-8" tabindex="-1"></a>  <span class="kw">public</span> <span class="dt">boolean</span> <span class="fu">jeZnizanaCena</span><span class="op">()</span> <span class="op">{</span> <span class="kw">...</span> <span class="op">}</span></span>
<span id="Zivilo-9"><a href="P9.html#Zivilo-9" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<script>
  $(document).ready(function() {
    $("#Zivilo").markRegExp(/Zivilo/, options_dodaj);
    $("#Zivilo").markRegExp(/(String|Date|double) \w+/, options_dodaj);
    $("#Zivilo").markRegExp(/boolean jeZnizanaCena\(\)/, options_dodaj);
  });
</script>
<p>Ime razreda v razrednem diagramu se v programskem jeziku Java spremeni v razred. Lastnosti se spremenijo v spremenljivke, operacije postanejo metode. Preslikavo lahko uporabimo tudi v obratno smer, da pretvorimo kodo v razredni diagram.</p>
<blockquote>
<p><strong>Opomba</strong>: V zgornjem primeru so vsi elementi (spremenljivke in metode) <strong>javni</strong> <em>(angl. public)</em>, kar pomeni, da lahko do njih dostopamo iz poljubnega razreda. Kasneje si bomo pogledali tudi <strong>modifikatorje dostopa</strong> <em>(angl. <a href="https://en.wikipedia.org/wiki/Access_modifiers"><i class="fa-brands fa-wikipedia-w"></i>access modifiers</a>)</em> za bolj nadzorovan dostop.</p>
</blockquote>
</div>
<div id="ovijanje-1" class="section level4 hasAnchor" number="16.2.4.2">
<h4><span class="header-section-number">16.2.4.2</span> Ovijanje<a href="P9.html#ovijanje-1" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Načrtovalsko načelo ovijanja opredeljuje naslednje ideje:</p>
<ul>
<li>podatki in funkcije, ki manipulirajo s temi podatki, so združeni v samostojen objekt,</li>
<li>podatki in funkcije objekta so lahko izpostavljeni ali dostopnih iz drugih objektov,</li>
<li>podatke in funkcije objekta je mogoče omejiti na samo znotraj objekta.</li>
</ul>
<p>V UML razrednem diagramu je enkapsulacija izražena tako, da so vsi pomembni podatki objekta definirani v atributih razreda in s posebnimi metodami zagotovimo dostop do teh atributov.</p>
<p>UML razredni diagrami nam omogočajo prikaz ovijanja. Sam razredni diagram že združuje podatke in funkcije v samostojnem objektu. Pri tem pa lahko dostop in omejitev (dva vidika vidnosti) predstavimo z uporabo simbolov oz. barvnih ikon.</p>

<div class="figure" style="text-align: center"><span style="display:block;" id="fig:RD-student"></span>
<img src="https://teaching.lavbic.net/plantuml/svg/POux3i8m44Hxds8b6X2YH4AKH50ZvGHER1o3yKRhJL8WxiuwuITeNCoRDzvqyR7LfAzG1vqIt1H0fUkB8-oYAJ0WmT1ujZb7CfQcRBO-x3RxGb9DXCCKLa5CTLVfFVgPgiS6auv9a8siWZqnC09vrp0OJxPcZr6fwPAIEoEryQ9LYtqh_6otS0geEMT92luiVnq9dNos5OLyT9cjv5awoyUNDrzyp6Nw1cCgj4TldbRvivpbztQs_meJVQtS7m00" alt="Razredni diagram za študenta PlantUML" width="220" />
<p class="caption">
Slika 16.4: Razredni diagram za študenta <a href="https://teaching.lavbic.net/plantuml/uml/POux3i8m44Hxds8b6X2YH4AKH50ZvGHER1o3yKRhJL8WxiuwuITeNCoRDzvqyR7LfAzG1vqIt1H0fUkB8-oYAJ0WmT1ujZb7CfQcRBO-x3RxGb9DXCCKLa5CTLVfFVgPgiS6auv9a8siWZqnC09vrp0OJxPcZr6fwPAIEoEryQ9LYtqh_6otS0geEMT92luiVnq9dNos5OLyT9cjv5awoyUNDrzyp6Nw1cCgj4TldbRvivpbztQs_meJVQtS7m00"><small><i class='fas fa-project-diagram' style='padding-right:4px'></i>PlantUML</small></a>
</p>
</div>
<p>V tem primeru sta atributa <code>povprecje</code> in <code>studijskiProgram</code> skrita pred <strong>javnim</strong> <em>(angl. public)</em> dostopom, kar označimo z znakom <code>-</code> oz. rdečo ikono pravokotnika. To pomeni, da je metoda ali atribut <strong>zaseben</strong> <em>(angl. private)</em> in da je do njega mogoče dostopati samo znotraj razreda. Po drugi strani so operacije javne, kar označuje znak <code>+</code> oz. zelena ikona kroga. To pomeni, da je do metode mogoče javno dostopati. V tem primeru se lahko javne metode uporabijo za manipulacijo s študentovim povprečje, preprečuje pa neposredno manipulacijo atributa <code>povprecje</code> in nadzoruje dostop do podatkov in njihovo spreminjanje.</p>
<p>Ovijanje nam v UML razrednih diagram pomaga določiti vrata za nadzor nad podatki z uporabo samo javnih metod za dostop do podatkovnih atributov razreda, kar ohranja <strong>celovitov podatkov</strong> <em>(angl. data integrity)</em>.</p>
<p>Za ohranjanje celovitosti podatkov se običajno uporabljata naslednji metodi:</p>
<ul>
<li>metode pridobivanja <em>(angl. getter methods)</em>, ki imajo običajno obliko <code>get&lt;ime atributa&gt;</code> in se ponavadi uporabljajo za pridobivanje zasebnih podatkov,</li>
<li>metode za spreminjanje podatkov <em>(angl. setter methods)</em>, ki imajo običajno obliko <code>set&lt;ime atributa&gt;</code> in se ponavadi uporabljajo za varno nastavitev vrednosti zasebnega atributa.</li>
</ul>
<p>Tovrstne metode pomagajo zagotavljati odobren način dostopa do podatkov.</p>
</div>
<div id="razgradnja-1" class="section level4 hasAnchor" number="16.2.4.3">
<h4><span class="header-section-number">16.2.4.3</span> Razgradnja<a href="P9.html#razgradnja-1" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Načrtovalsko načelo razgradnje celoto razdeli na različne dele. Deluje tudi v obratni smeri, kjer ločene dele z različnimi funkcionalnostmi združimo v celoto. Pri razgradnji obstajajo tri vrste odnosov, ki določajo interakcijo med celoto in posameznimi deli:</p>
<ul>
<li><strong>asociacija</strong> <em>(angl. <a href="https://en.wikipedia.org/wiki/Association_(object-oriented_programming)"><i class="fa-brands fa-wikipedia-w"></i>association</a>)</em> (glej poglavje <a href="P9.html#asociacija-opis">16.2.4.3.1</a>),</li>
<li><strong>agregacija</strong> <em>(angl. <a href="https://en.wikipedia.org/wiki/Aggregation"><i class="fa-brands fa-wikipedia-w"></i>aggregation</a>)</em> (glej poglavje <a href="P9.html#agregacija-opis">16.2.4.3.2</a>),</li>
<li><strong>kompozicija</strong> <em>(angl. <a href="https://en.wikipedia.org/wiki/Object_composition"><i class="fa-brands fa-wikipedia-w"></i>composition</a>)</em> (glej poglavje <a href="P9.html#kompozicija-opis">16.2.4.3.3</a>).</li>
</ul>
<p>Vsi trije so uporabni pri načrtovanju programske rešitve, zato si jih bomo v nadaljevanju podrobneje ogledali.</p>
<div id="asociacija-opis" class="section level5 hasAnchor" number="16.2.4.3.1">
<h5><span class="header-section-number">16.2.4.3.1</span> Asociacija<a href="P9.html#asociacija-opis" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p><strong>Asociacija</strong> <em>(angl. <a href="https://en.wikipedia.org/wiki/Association_(object-oriented_programming)"><i class="fa-brands fa-wikipedia-w"></i>Association</a>)</em> prikazuje ohlapno razmerje med dvema objektoma, ki lahko nekaj časa sodelujeta drug z drugim. Objekta nista medsebojno odvisna, saj če en objekt odstranimi, lahko drugi še naprej obstaja in v razmerju je lahko poljubno število vsakega objekta. En objekt tako ne pripada drugemu.</p>
<p>Primer razmerja asociacije je lahko povezava med osebo in hotelom. Oseba lahko komunicira s hotelom, vendar ga ne more imeti v lasti. Hotel lahko komunicira z različnimi osebami.</p>
<p>Primer asociacija v UML razrednem diagramu prikazuje slika <a href="P9.html#fig:RD-oseba-hotel#fig:RD-oseba-hotel">16.5</a>.</p>

<div class="figure" style="text-align: center"><span style="display:block;" id="fig:RD-oseba-hotel"></span>
<img src="../../plantuml/svg/HOwn3i8m34HtVuK56r8H2n8p5OYDRt0IqqPD4sG7TK3yEw4HxUJpk_F9ElZu9A4HRI1LV0EY8JjqabxHjIaamQdtcNyyYMEfR7kyda-Njb0IILE59fHB-80kfMkLdHDPA6gnE6O8_CYO4uhl-epE2zliKmJelMCSUJGi2b3_sk1TsL2Pf5KknYrb3jMO9S0_UjZlTsKqJRCkS-GB" alt="Asociacija med osebo in hotelom PlantUML" width="280" />
<p class="caption">
Slika 16.5: Asociacija med osebo in hotelom <a href="https://teaching.lavbic.net/plantuml/uml/HOwn3i8m34HtVuK56r8H2n8p5OYDRt0IqqPD4sG7TK3yEw4HxUJpk_F9ElZu9A4HRI1LV0EY8JjqabxHjIaamQdtcNyyYMEfR7kyda-Njb0IILE59fHB-80kfMkLdHDPA6gnE6O8_CYO4uhl-epE2zliKmJelMCSUJGi2b3_sk1TsL2Pf5KknYrb3jMO9S0_UjZlTsKqJRCkS-GB"><small><i class='fas fa-project-diagram' style='padding-right:4px'></i>PlantUML</small></a>
</p>
</div>
<p>Ravna črta med obema objektoma pomeni, da med <code>Oseba</code> in <code>Hotel</code> obstaja razmerje, in to razmerje je asociacija. Notacija <code>0..*</code> na desni strani črte prikazuje, da je objekt <code>Oseba</code> povezan z 0 ali več objekti <code>Hotel</code>, medtem ko notacija <code>0..*</code> na levi strani črte pomeni, da je objekt <code>Hotel</code> povezan z 0 ali več objekti <code>Oseba</code>.</p>
<p>Asociacijo lahko predstavimo tudi v izvorni kodi programskega jezika Java.</p>
<p><code>Student.java</code></p>
<div class="sourceCode" id="cb157"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb157-1"><a href="P9.html#cb157-1" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> Student <span class="op">{</span></span>
<span id="cb157-2"><a href="P9.html#cb157-2" tabindex="-1"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">igraj</span><span class="op">(</span>Sport sport<span class="op">)</span> <span class="op">{</span></span>
<span id="cb157-3"><a href="P9.html#cb157-3" tabindex="-1"></a>    izvedba<span class="op">.</span><span class="fu">igraj</span><span class="op">(</span>sport<span class="op">);</span></span>
<span id="cb157-4"><a href="P9.html#cb157-4" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb157-5"><a href="P9.html#cb157-5" tabindex="-1"></a>  <span class="kw">...</span></span>
<span id="cb157-6"><a href="P9.html#cb157-6" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>V tem primeru izvorne kode objektu <code>Student</code> posredujemo objekt <code>Sport</code> za igranje, vendar študent nima nobenega športa. Z njim komunicira zgolj pri igranju. Omenjena objekta sta popolnoma ločena in imata opredeljen ohlapen odnos. Študent se lahko ukvarja s poljubnim športom in s športom se lahko ukvarja poljubno število študentov.</p>
</div>
<div id="agregacija-opis" class="section level5 hasAnchor" number="16.2.4.3.2">
<h5><span class="header-section-number">16.2.4.3.2</span> Agregacija<a href="P9.html#agregacija-opis" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p><strong>Agregacija</strong> <em>(angl. <a href="https://en.wikipedia.org/wiki/Aggregation"><i class="fa-brands fa-wikipedia-w"></i>Aggregation</a>)</em> je razmerje tipa <strong><code>ima</code></strong>, kjer ima celota dele, ki ji pripadajo. Deli se lahko v tem razmerju delijo med celotami. Agregacijski odnosi so običajno šibki, kar pomeni, da čeprav deli pripadajo celoti, lahko obstajajo tudi neodvisno. Primer razmerja agregacije je odnos med letalom in njegovo posadko. Brez posadke letalska družba ne more nuditi storitev, vendar letalska družba ne preneha obstajati, če ga posadka zapusti. Tudi posadka ne preneha obstajati, če ni del letalske družbe.</p>
<p>Agregacijo lahko v UML razrednemu diagramu predstavimo s simbolom praznega romba, kot prikazuje slika <a href="P9.html#fig:RD-letalska-druzba-clan-posadke#fig:RD-letalska-druzba-clan-posadke">16.6</a>.</p>

<div class="figure" style="text-align: center"><span style="display:block;" id="fig:RD-letalska-druzba-clan-posadke"></span>
<img src="https://teaching.lavbic.net/plantuml/svg/LOunRiCm34Ltde98jW0EkWJeNAUTElG0NIYBZGNBOa3A290WDyYPEhNtgb8LSJCHV9_lWpQ4j2Ub4Rj8PdW2H4VTi5EPacybYkAX3vclNDIpLhRSl3mzFhU5ageSAdInc706kvNELTtlHLPALY9E6I9_PCo26dPzHX-Kknma0VJ1CuuyEbO3g7yj45yvKxI14DyJejVf-zELPO5ajsohqz7Hx7nT8gKgxCN83_mdj8M_LG9mRvU3X_LwLOOqJJDl_vGV" alt="Agregacija med letalsko družbo in članom posadke PlantUML" width="320" />
<p class="caption">
Slika 16.6: Agregacija med letalsko družbo in članom posadke <a href="https://teaching.lavbic.net/plantuml/uml/LOunRiCm34Ltde98jW0EkWJeNAUTElG0NIYBZGNBOa3A290WDyYPEhNtgb8LSJCHV9_lWpQ4j2Ub4Rj8PdW2H4VTi5EPacybYkAX3vclNDIpLhRSl3mzFhU5ageSAdInc706kvNELTtlHLPALY9E6I9_PCo26dPzHX-Kknma0VJ1CuuyEbO3g7yj45yvKxI14DyJejVf-zELPO5ajsohqz7Hx7nT8gKgxCN83_mdj8M_LG9mRvU3X_LwLOOqJJDl_vGV"><small><i class='fas fa-project-diagram' style='padding-right:4px'></i>PlantUML</small></a>
</p>
</div>
<p>V tem diagramu smo spet uporabili ravno črto za prikaz odnosa med objektoma letalske družbe in članom posadke. Notacija <code>0..*</code> se ponovno uporablja za prikaz, kjer je objekt povezan z 0 ali več drugimi objekti. Prazen romb označuje, kateri objekt se šteje za celoto in ne del v tem razmerju.</p>
<p>Agregacijo lahko predstavimo tudi v izvorni kodi programskega jezika Java.</p>
<p><code>LetalskaDruzba.java</code></p>
<div class="sourceCode" id="cb158"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb158-1"><a href="P9.html#cb158-1" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> LetalskaDruzba <span class="op">{</span></span>
<span id="cb158-2"><a href="P9.html#cb158-2" tabindex="-1"></a>  <span class="kw">private</span> <span class="bu">ArrayList</span><span class="op">&lt;</span>ClanPosadke<span class="op">&gt;</span> claniPosadke<span class="op">;</span></span>
<span id="cb158-3"><a href="P9.html#cb158-3" tabindex="-1"></a>  <span class="kw">public</span> <span class="fu">LetalskaDruzba</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb158-4"><a href="P9.html#cb158-4" tabindex="-1"></a>    claniPosadke <span class="op">=</span> <span class="kw">new</span> <span class="bu">ArrayList</span><span class="op">&lt;</span>ClanPosadke<span class="op">&gt;();</span></span>
<span id="cb158-5"><a href="P9.html#cb158-5" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb158-6"><a href="P9.html#cb158-6" tabindex="-1"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">dodaj</span><span class="op">(</span>ClanPosadke clanPosadke<span class="op">)</span> <span class="op">{</span></span>
<span id="cb158-7"><a href="P9.html#cb158-7" tabindex="-1"></a>    <span class="kw">...</span></span>
<span id="cb158-8"><a href="P9.html#cb158-8" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb158-9"><a href="P9.html#cb158-9" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>V razredu <code>LetalskaDruzba</code> je seznam članov posadke, ki ga inicializiramo tako, da je prazen, javna metoda <code>dodaj</code> pa omogoča dodajanje novih članov posadke. Potniško letalo ima posadko, kar pomeni, da ima lahko letalo nič ali več članov posadkov.</p>
</div>
<div id="kompozicija-opis" class="section level5 hasAnchor" number="16.2.4.3.3">
<h5><span class="header-section-number">16.2.4.3.3</span> Kompozicija<a href="P9.html#kompozicija-opis" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p><strong>Kompozicija</strong> <em>(angl. <a href="https://en.wikipedia.org/wiki/Object_composition"><i class="fa-brands fa-wikipedia-w"></i>Composition</a>)</em> je ena najbolj odvisnih razmerij razgradnje. To je močno razmerje tipa <strong><code>ima</code></strong>, kjer celota ne more obstajati brez svojih delov, saj v primeru, ko je celota uničena, tudi deli ne morejo obstajati. V tem razmerju lahko do delov ponavadi dostopamo zgolj preko celote, kjer so deli ziključno povezani s celoto. Primer razmerja kompozicije je odnos med hišo in prostorom, kjer je hiša sestavljena iz več prostorov. Če v tem primeru odstranimo hišo, tudi prostori ne obstajajo več.</p>
<p>Kompozicijo lahko na razrednem diagramu predstavimo s simbolom polnega romba, kot to prikazuje slika <a href="P9.html#fig:RD-hisa-prostor#fig:RD-hisa-prostor">16.7</a>.</p>

<div class="figure" style="text-align: center"><span style="display:block;" id="fig:RD-hisa-prostor"></span>
<img src="../../plantuml/svg/HOwn3i8m34HtVuK5MwLMOa1YfW8nyWjkOjgeQOBie0w8VoUag9rilpkVJaSNdYGqeV6aYcz0xCYClSHNi6tqKN0UNE8VZs9P5hO_Ni-dIvifYSHvWPtFd_01NKEtA5CSIIXebZWayFn8c2AAwuU4rWcRv68069nbd7ZgM1HWwRN3crFAWxHiAxvBr9IJY_8_08gvgkiwyqFJL9ln2m00" alt="Kompozicija med hišo in prostorom PlantUML" width="280" />
<p class="caption">
Slika 16.7: Kompozicija med hišo in prostorom <a href="https://teaching.lavbic.net/plantuml/uml/HOwn3i8m34HtVuK5MwLMOa1YfW8nyWjkOjgeQOBie0w8VoUag9rilpkVJaSNdYGqeV6aYcz0xCYClSHNi6tqKN0UNE8VZs9P5hO_Ni-dIvifYSHvWPtFd_01NKEtA5CSIIXebZWayFn8c2AAwuU4rWcRv68069nbd7ZgM1HWwRN3crFAWxHiAxvBr9IJY_8_08gvgkiwyqFJL9ln2m00"><small><i class='fas fa-project-diagram' style='padding-right:4px'></i>PlantUML</small></a>
</p>
</div>
<p>Črta med objektoma <code>Hisa</code> in <code>Prostor</code> prikazuje medsebojno razmerje, poln romb poleg objekta <code>Hisa</code> pa pomeni, da je <code>Hisa</code> v tem razmerju celota. Če je romb poln, to pomeni, da je razmerje tipa <code>ima</code> močno, kjer objekta eden brez drugega ne moreta obstajati. Notacija <code>1..*</code> pomeni, da mora pri objektu <code>Hisa</code> obstajati vsaj 1 ali več objektov <code>Prostor</code>.</p>
<p>Kompozicijo lahko predstavimo tudi z izvorno kodo v programskem jeziku Java.</p>
<p><code>Hisa.java</code></p>
<div class="sourceCode" id="cb159"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb159-1"><a href="P9.html#cb159-1" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> Hisa <span class="op">{</span></span>
<span id="cb159-2"><a href="P9.html#cb159-2" tabindex="-1"></a>  <span class="kw">private</span> Prostor prostor<span class="op">;</span></span>
<span id="cb159-3"><a href="P9.html#cb159-3" tabindex="-1"></a>  <span class="kw">public</span> <span class="fu">Hisa</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb159-4"><a href="P9.html#cb159-4" tabindex="-1"></a>    prostor <span class="op">=</span> <span class="kw">new</span> <span class="fu">Prostor</span><span class="op">();</span></span>
<span id="cb159-5"><a href="P9.html#cb159-5" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb159-6"><a href="P9.html#cb159-6" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>V tem primeru kreiramo objekt <code>Prostor</code> hkrati s kreiranjem objekta <code>Hisa</code> in sicer ob kreiranju novega primerka <code>Hisa</code>. Objekt <code>Prostor</code> ni treba kreirati drugje in ga tudi ni treba posredovati pri kreiranju objekta <code>Hisa</code>. Oba dela sta tesno medsebojno odvisna, kjer eden ne more obstajati brez drugega.</p>
</div>
</div>
<div id="posploševanje-1" class="section level4 hasAnchor" number="16.2.4.4">
<h4><span class="header-section-number">16.2.4.4</span> Posploševanje<a href="P9.html#posploševanje-1" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Načrtovalsko načelo <strong>posploševanja</strong> <em>(angl. <a href="https://en.wikipedia.org/wiki/Generalization"><span style="white-space:nowrap"><i class="fa-brands fa-wikipedia-w"></i>generalization</span></a>)</em> vzame vse ponavljajoče skupne lastnosti med več razredi in jih dodeli v nov razred, tako da je mogoče izvorno kodo ponovno uporabiti, skupne lastnosti pa podrazredi podedujejo.</p>
<p>Posploševanje in dedovanje <em>(angl. <a href="https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)"><i class="fa-brands fa-wikipedia-w"></i>inheritance</a>)</em> lahko z razrednim diagramom prikažemo z uporabo zapolnjene puščice, kot prikazuje slika <a href="P9.html#fig:RD-lev-zival#fig:RD-lev-zival">16.8</a>.</p>

<div class="figure" style="text-align: center"><span style="display:block;" id="fig:RD-lev-zival"></span>
<img src="../../plantuml/svg/HOsz3i8m38HtFuK5SqSa9WOgc7W2DYUnQDJyL7P_XiAxanAfJ3v_TpvhxzD0GX5j85LS0T6GxL-If-JQ7BBWqlcHDvx5iLHsFDslvrjRA8dafK8JoYLyGFVIVvNz9KQXfCNYD09qtZ56ZeP50Uh_0pxzJA5CqYftuy5pnKK0R5ip3StxKcDV" alt="Dedovanje med levom in živaljo PlantUML" width="85" />
<p class="caption">
Slika 16.8: Dedovanje med levom in živaljo <a href="https://teaching.lavbic.net/plantuml/uml/HOsz3i8m38HtFuK5SqSa9WOgc7W2DYUnQDJyL7P_XiAxanAfJ3v_TpvhxzD0GX5j85LS0T6GxL-If-JQ7BBWqlcHDvx5iLHsFDslvrjRA8dafK8JoYLyGFVIVvNz9KQXfCNYD09qtZ56ZeP50Uh_0pxzJA5CqYftuy5pnKK0R5ip3StxKcDV"><small><i class='fas fa-project-diagram' style='padding-right:4px'></i>PlantUML</small></a>
</p>
</div>
<p>Zapolnjena puščica označuje, da sta dva razreda povezana z dedovanjem. Nadrazred je na vrhu puščice, medtem ko je podrazred na repu. Običajno je, da je puščica obrnjena navzgor in tudi razredni diagrami je strukturiran tako, da so nadrazredi vedno na vrhu, podrazredi pa spodaj.</p>
<p>Atributov in vedenj podedovanega razreda ni treba prepisati v podrazred. Namesto tega puščica simbolizira, da bo podrazred vseboval atribute in metode nadrazreda. Nadrazredi so posplošeni razredi, podrazredi pa specializirani razredi.</p>
<p>UML razredni diagram lahko prevedemo v izvorno kodo objektno usmerjenega programskega jezika. Kar nadaljujmo s prejšnjim primerom.</p>

<div class="figure" style="text-align: center"><span style="display:block;" id="fig:RD-lev-zival-podrobno"></span>
<img src="https://teaching.lavbic.net/plantuml/svg/LOunRm8n38Nt_0ghB4NLZKZL3Hr0TAewb8tDt5c7Zn2Vd10aAF-zILE5iYH-NvvVdZ-mcr3n29r5x-5g07RO7GQLa-jNOaNXlET0cOlsf8ND5k_Br_KgKLILSu4xcpRDpVWQUe_gVXr1qVdqH2uOKtvyWYr7jEb6_pVc4ZCVABALJnbQu6I_eo-Q95R8HsfX4vJTa6JJfEDbBpq_prk8mdtMWRe7FT9OvQts-A1OMkJXMiCkgAD4_hTWig4vJSttMsdy0m00" alt="Dedovanje med levom in živaljo z atributi in metodami PlantUML" width="140" />
<p class="caption">
Slika 16.9: Dedovanje med levom in živaljo z atributi in metodami <a href="https://teaching.lavbic.net/plantuml/uml/LOunRm8n38Nt_0ghB4NLZKZL3Hr0TAewb8tDt5c7Zn2Vd10aAF-zILE5iYH-NvvVdZ-mcr3n29r5x-5g07RO7GQLa-jNOaNXlET0cOlsf8ND5k_Br_KgKLILSu4xcpRDpVWQUe_gVXr1qVdqH2uOKtvyWYr7jEb6_pVc4ZCVABALJnbQu6I_eo-Q95R8HsfX4vJTa6JJfEDbBpq_prk8mdtMWRe7FT9OvQts-A1OMkJXMiCkgAD4_hTWig4vJSttMsdy0m00"><small><i class='fas fa-project-diagram' style='padding-right:4px'></i>PlantUML</small></a>
</p>
</div>
<p>Na diagramu (glej sliko <a href="P9.html#fig:RD-lev-zival-podrobno#fig:RD-lev-zival-podrobno">16.9</a>) je razred <code>Lev</code> podrazred, razred <code>Zival</code> pa nadrazred. Podrazred podeduje vse atribute in vedenja nadrazreda. Pri implementacijo bomo tako vse atribute in vedenja nadrazreda prenesli v podrazred.</p>
<p>Opazimo lahko tudi uporabo simbola <code>#</code> oz. rumenega simbola romba, ki označuje, da so atributi razreda <code>Zival</code> <strong>zaščiteni</strong> <em>(angl. protected)</em>.</p>
<p>Do zaščitenih atributov lahko v programskem jeziku Java dostopajo samo:</p>
<ul>
<li>enkapsulirani razred,</li>
<li>vsi podrazredi in</li>
<li>vsi razredi znotraj istega <strong>paketa</strong>.</li>
</ul>
<p>V programskem jeziku Java lahko s pomočjo paketov organiziramo razrede v <strong>imenski prostor</strong> <em>(angl. namespace)</em>, ki te razrede predstavlja.</p>
<p>UML razredni diagram na sliki <a href="P9.html#fig:RD-lev-zival-podrobno#fig:RD-lev-zival-podrobno">16.9</a> lahko tudi prevedemo v izvorno kodo programskega jezika Java.</p>
<p><code>Lev.java</code></p>
<div class="sourceCode" id="Lev-extends"><pre class="sourceCode java"><code class="sourceCode java"><span id="Lev-extends-1"><a href="P9.html#Lev-extends-1" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> Lev <span class="kw">extends</span> Zival <span class="op">{</span></span>
<span id="Lev-extends-2"><a href="P9.html#Lev-extends-2" tabindex="-1"></a>  <span class="kw">public</span> <span class="fu">Lev</span><span class="op">(</span><span class="bu">String</span> ime<span class="op">,</span> <span class="dt">int</span> steviloNog<span class="op">,</span> <span class="dt">int</span> steviloRepov<span class="op">)</span> <span class="op">{</span></span>
<span id="Lev-extends-3"><a href="P9.html#Lev-extends-3" tabindex="-1"></a>    <span class="kw">super</span><span class="op">(</span>ime<span class="op">,</span> steviloNog<span class="op">,</span> steviloRepov<span class="op">);</span></span>
<span id="Lev-extends-4"><a href="P9.html#Lev-extends-4" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="Lev-extends-5"><a href="P9.html#Lev-extends-5" tabindex="-1"></a>  <span class="kw">public</span> <span class="fu">zarjovi</span><span class="op">()</span> <span class="op">{</span> <span class="kw">...</span> <span class="op">}</span></span>
<span id="Lev-extends-6"><a href="P9.html#Lev-extends-6" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<script>
  $(document).ready(function() {
    $("#Lev-extends").markRegExp(/extends/, options_dodaj);
    $("#Lev-extends").markRegExp(/zarjovi\(\)/, options_dodaj);
  });
</script>
<p>Nobenega od atributov in vedenj, podedovanih iz nadrazreda <code>Zival</code>, ni treba deklarirati. To odraža UML razredni diagram, saj so v nadrazredu in podrazredu deklarirani samo specializirani atributi in metode. Ne pozabite, da UML razredni diagram predstavlja naš načrt. Ker podedovanih atributov in vedenj ni treba ponovno navesti v izvorni kodi, jih tudi v podrazredu na diagramu ni treba navesti.</p>
<p>Dedovanje v programskem jeziku Java deklariramo s ključno besedo <strong><code>extends</code></strong>. Objekti se kot primerki razredi kreirajo z uporabo konstruktorjev. Pri dedovanju je potrebno, če želimo primerek podrazreda, nadrazredu dati možnost, da ustrezno pripravi atribute objekta. Razredi lahko imajo <strong>implicitne konstruktorje</strong> <em>(angl. implicit contructors)</em> ali <strong>eksplicitne konstruktorje</strong> <em>(angl. explicit contructors)</em>.</p>
<p>Spodaj je prikazan primer implicitnega konstruktorja.</p>
<p><code>Zival.java</code></p>
<div class="sourceCode" id="cb160"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb160-1"><a href="P9.html#cb160-1" tabindex="-1"></a><span class="kw">public</span> <span class="kw">abstract</span> <span class="kw">class</span> Zival <span class="op">{</span></span>
<span id="cb160-2"><a href="P9.html#cb160-2" tabindex="-1"></a>  <span class="kw">protected</span> <span class="dt">int</span> steviloNog<span class="op">;</span></span>
<span id="cb160-3"><a href="P9.html#cb160-3" tabindex="-1"></a>  pubic <span class="dt">void</span> <span class="fu">hodi</span><span class="op">()</span> <span class="op">{</span> <span class="kw">...</span> <span class="op">}</span></span>
<span id="cb160-4"><a href="P9.html#cb160-4" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>V tem primeru nismo napisali lastnega konstrukturja, kjer uporabi privzeti konstruktor, ki vsem atributom dodeli vrednost <code>0</code> ali <code>null</code>.</p>
<p>V naslednjem primeru pa nam bo eksplicitni konstruktor omogočil kreiranje primerkov živali s toliko nogami, kot jih želimo. Eksplicitni konstruktorji omogočajo namreč dodeljevanje vrednosti atributom med kreiranjem primerka.</p>
<p><code>Zival.java</code></p>
<div class="sourceCode" id="Zival-eksplicitni-konstruktor"><pre class="sourceCode java"><code class="sourceCode java"><span id="Zival-eksplicitni-konstruktor-1"><a href="P9.html#Zival-eksplicitni-konstruktor-1" tabindex="-1"></a><span class="kw">public</span> <span class="kw">abstract</span> <span class="kw">class</span> Zival <span class="op">{</span></span>
<span id="Zival-eksplicitni-konstruktor-2"><a href="P9.html#Zival-eksplicitni-konstruktor-2" tabindex="-1"></a>  <span class="kw">protected</span> <span class="dt">int</span> steviloNog<span class="op">;</span></span>
<span id="Zival-eksplicitni-konstruktor-3"><a href="P9.html#Zival-eksplicitni-konstruktor-3" tabindex="-1"></a>  <span class="kw">public</span> <span class="fu">Zival</span><span class="op">(</span><span class="dt">int</span> noge<span class="op">)</span> <span class="op">{</span></span>
<span id="Zival-eksplicitni-konstruktor-4"><a href="P9.html#Zival-eksplicitni-konstruktor-4" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="fu">steviloNog</span> <span class="op">=</span> noge<span class="op">;</span></span>
<span id="Zival-eksplicitni-konstruktor-5"><a href="P9.html#Zival-eksplicitni-konstruktor-5" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="Zival-eksplicitni-konstruktor-6"><a href="P9.html#Zival-eksplicitni-konstruktor-6" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><code>Lev.java</code></p>
<div class="sourceCode" id="Lev-eksplicitni-konstruktor"><pre class="sourceCode java"><code class="sourceCode java"><span id="Lev-eksplicitni-konstruktor-1"><a href="P9.html#Lev-eksplicitni-konstruktor-1" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> Lev <span class="kw">extends</span> Zival <span class="op">{</span></span>
<span id="Lev-eksplicitni-konstruktor-2"><a href="P9.html#Lev-eksplicitni-konstruktor-2" tabindex="-1"></a>  <span class="kw">public</span> <span class="fu">Lev</span><span class="op">(</span><span class="dt">int</span> noge<span class="op">)</span> <span class="op">{</span></span>
<span id="Lev-eksplicitni-konstruktor-3"><a href="P9.html#Lev-eksplicitni-konstruktor-3" tabindex="-1"></a>    <span class="kw">super</span><span class="op">(</span>noge<span class="op">);</span></span>
<span id="Lev-eksplicitni-konstruktor-4"><a href="P9.html#Lev-eksplicitni-konstruktor-4" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="Lev-eksplicitni-konstruktor-5"><a href="P9.html#Lev-eksplicitni-konstruktor-5" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<script>
  $(document).ready(function() {
    $("#Zival-eksplicitni-konstruktor").markRegExp(/\s+?public Zival[\s\S]+?}/, options_dodaj);
    $("#Lev-eksplicitni-konstruktor").markRegExp(/\s+?super.+/, options_dodaj);
  });
</script>
<p>Konstruktor podrazreda mora referencirati konstruktor nadrazreda, saj v nasprotnem primeru atributi nadrazreda ne bi bili ustrezno inicializirani. Za dostop do atributov, metod in konstruktorjev nadrazreda uporabimo razervirano besedo <strong><code>super</code></strong>.</p>
<p>Podrazredi lahko <strong>preglasijo</strong> <em>(angl. override)</em> metode svojega nadrazreda, kar pomeni, da lahko razred zagotovi lastno implementacijo posamezne metode podedovanega nadrazreda.</p>
<p><code>Zival.java</code></p>
<div class="sourceCode" id="Zival-override"><pre class="sourceCode java"><code class="sourceCode java"><span id="Zival-override-1"><a href="P9.html#Zival-override-1" tabindex="-1"></a><span class="kw">public</span> <span class="kw">abstract</span> <span class="kw">class</span> Zival <span class="op">{</span></span>
<span id="Zival-override-2"><a href="P9.html#Zival-override-2" tabindex="-1"></a>  <span class="kw">protected</span> in steviloNog<span class="op">;</span></span>
<span id="Zival-override-3"><a href="P9.html#Zival-override-3" tabindex="-1"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">hodi</span><span class="op">()</span> <span class="op">{</span></span>
<span id="Zival-override-4"><a href="P9.html#Zival-override-4" tabindex="-1"></a>    <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Žival hodi.&quot;</span><span class="op">);</span></span>
<span id="Zival-override-5"><a href="P9.html#Zival-override-5" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="Zival-override-6"><a href="P9.html#Zival-override-6" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><code>Lev.java</code></p>
<div class="sourceCode" id="Lev-override"><pre class="sourceCode java"><code class="sourceCode java"><span id="Lev-override-1"><a href="P9.html#Lev-override-1" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> Lev <span class="kw">extends</span> Zival <span class="op">{</span></span>
<span id="Lev-override-2"><a href="P9.html#Lev-override-2" tabindex="-1"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">hodi</span><span class="op">()</span> <span class="op">{</span></span>
<span id="Lev-override-3"><a href="P9.html#Lev-override-3" tabindex="-1"></a>    <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Raje bi spal.&quot;</span><span class="op">);</span></span>
<span id="Lev-override-4"><a href="P9.html#Lev-override-4" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="Lev-override-5"><a href="P9.html#Lev-override-5" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<script>
  $(document).ready(function() {
    $("#Zival-override").markRegExp(/\s+?public void hodi[\s\S]+?}/, options_dodaj);
    $("#Lev-override").markRegExp(/\s+?public void hodi[\s\S]+?}/, options_dodaj);
  });
</script>
<p>V zgornjem primeru je razred <code>Lev</code> preglasil metodo <code>hodi</code> razreda <code>Zival</code>. Če bi ga prosili naj hodi, bi nam sistem sporočil, da bi objekt <code>Lev</code> raje spal.</p>
<div id="vrste-dedovanja" class="section level5 hasAnchor" number="16.2.4.4.1">
<h5><span class="header-section-number">16.2.4.4.1</span> Vrste dedovanja<a href="P9.html#vrste-dedovanja" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>Programski jezik Java podpira več vrst dedovanja. Zgornji primeri predstavljajo <strong>dedovanje implementacije</strong> <em>(angl. implementation inheritance)</em>.</p>
<p>V programskem jeziku Java je dovoljeno dedovanje posamezne implementacije, kar pomeni, da medtem ko ima nadrazred lahko več podrazredov, lahko podrazred deduje samo od enega nadrazreda.</p>
<p>Npr. razred <code>Zival</code> je lahko nadrazred večim podrazredom: <code>Lev</code>, <code>Volk</code> ali <code>Jelen</code>. Vsak izmed teh razredov ima lahko specializirano vedenje ali lasnosti, tako da objekt <code>Lev</code> ve, kako rjoveti, vendar morde ne ve, kako zavijati, kot to zna objekt <code>Volk</code>.</p>
<p>Podrazredi so lahko tudi nadrazredi drugega razreda, kjer lahko dedovanje prehaja skozi poljubno število razredov.</p>
<p>Dedovanje omogoča posplošitev povezanih razredov v en sam nadrazred, podrazredom pa še vedno omogoča, ad obdržijo isti nabor atributov in vedenj. To odstrani tudi podvajanje v kodi in olajša izvajanje sprememb.</p>
</div>
<div id="dedovanje-vmesnika" class="section level5 hasAnchor" number="16.2.4.4.2">
<h5><span class="header-section-number">16.2.4.4.2</span> Dedovanje vmesnika<a href="P9.html#dedovanje-vmesnika" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>Drugi programski jeziki (npr. C++) podpirajo <strong>večkratno dedovanje</strong> <em>(angl. multiple inheritance)</em>, kar pomeni, da ima lahko podrazred dva ali več nadrazredov. Programski jezik Java naslavlja omejitev dedovanja posamezne implementacije tako, da ponuja <strong>dedovanje vmesnika</strong> <em>(angl. interface inheritance)</em>, ki je druga oblika posploševanja. Da bi to razumeli, je treba najprej predstaviti določene pojme programske jezika in načrtovanja.</p>
<p>Razred označujo vrsto objektov, kjer vrsta označuje, kaj lahko ti objekti počnejo preko javnih metod. Pri načrtovanju bo morda treba izraziti razmerje podtipov med dvema tipoma. Npr. primerki razreda <code>Lev</code> so objekti razreda <code>Lev</code>, ki lahko izvajajo specializirano vedenje levov. Levji tip je lahko tudi podtip živalskega tipa. Objekt <code>Lev</code> je torej tipa <code>Lev</code> in tipa <code>Zival</code> - objekt <code>Lev</code> se obnaša kot lev in kot žival, zato “je” lev žival.</p>
<p>V programskem jeziku Java se za podtip pogosto uporablja dedovanje implementacije s ključno besedo <strong><code>extends</code></strong>. Če podrazred razširja nadrazred, se bo obnašal kot nadrazred in njegov razred. Podrazred podeduje podrobnosti implementacije nadrazreda.</p>
<p>Vmesnik v programskem jeziku Java označuje tip, vendar vmesnik deklarira zgolj metode, brez konstruktorjev ali atributov. Določa pričakovano vedenje, vendar ne zagotavlja nobenih implementacijskih podrobnosti.</p>
<p>Vmesnik v programskem jeziku Java se lahko uporabi tudi za opredelitev podtipov. Če razred implementira vmesnik, potem se razred ne obnaša samostojno, ampak se pričakuje, da se bo obnašal v skladu z metodami, navedenimi v vmesniku. Razred mora zagotoviti podrobnosti implementacije metod vmesnika. Vmesnik je kot pogodba, ki jo treba izpolniti pri implementaciji razreda.</p>
<p>Pri dedovanju implementacije obstaja skladnost med tipom nadrazreda in tipom podrazreda. Objekt podrazreda je uporaben kjerkoli v programu, kadar imamo opravka s tipom nadrazreda. Podobno je pri dedovanju vmesnika prisotna skladnost med tipom vmesnika in tipom razreda, ki vmesnik implementira.</p>
<p>V programskem jeziku Java se za označevanje vmesnikov uporablja rezervirana beseda <strong><code>interface</code></strong>. Pred dejansko ime pogosto postavimo črko <code>I</code>, kar označuje vmesnik.</p>
<p><code>IZival.java</code></p>
<div class="sourceCode" id="cb161"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb161-1"><a href="P9.html#cb161-1" tabindex="-1"></a><span class="kw">public</span> <span class="kw">interface</span> IZival <span class="op">{</span></span>
<span id="cb161-2"><a href="P9.html#cb161-2" tabindex="-1"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">premikaj</span><span class="op">();</span></span>
<span id="cb161-3"><a href="P9.html#cb161-3" tabindex="-1"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">govori</span><span class="op">();</span></span>
<span id="cb161-4"><a href="P9.html#cb161-4" tabindex="-1"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">jej</span><span class="op">();</span></span>
<span id="cb161-5"><a href="P9.html#cb161-5" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Vmesnik <code>IZival</code> prikazuje, kako se žival giblje, govori in je, vendar ta vedenja na tem mestu nisto implementirana in tudi ni nikjer opisa, kako naj se vedenje izvede. Vmesnik prav tako ne zajema nobenih atributov nadrazreda, ker to niso atributi vedenja.</p>
<p>Če želimo vmesnik uporabiti, moramo izjaviti, da bomo izpolnili pogodbo, kot je opisano v vmesniku. V programskem jeziku Java je rezervirana beseda za to <strong><code>implements</code></strong>.</p>
<p><code>Lev.java</code></p>
<div class="sourceCode" id="Lev-IZival"><pre class="sourceCode java"><code class="sourceCode java"><span id="Lev-IZival-1"><a href="P9.html#Lev-IZival-1" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> Lev <span class="kw">implements</span> IZival <span class="op">{</span></span>
<span id="Lev-IZival-2"><a href="P9.html#Lev-IZival-2" tabindex="-1"></a>  <span class="co">/* Atributi leva */</span></span>
<span id="Lev-IZival-3"><a href="P9.html#Lev-IZival-3" tabindex="-1"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">premikaj</span><span class="op">()</span> <span class="op">{</span> <span class="kw">...</span> <span class="op">}</span></span>
<span id="Lev-IZival-4"><a href="P9.html#Lev-IZival-4" tabindex="-1"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">govori</span><span class="op">()</span> <span class="op">{</span> <span class="kw">...</span> <span class="op">}</span></span>
<span id="Lev-IZival-5"><a href="P9.html#Lev-IZival-5" tabindex="-1"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">jej</span><span class="op">()</span> <span class="op">{</span> <span class="kw">...</span> <span class="op">}</span></span>
<span id="Lev-IZival-6"><a href="P9.html#Lev-IZival-6" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<script>
  $(document).ready(function() {
    $("#Lev-IZival").markRegExp(/implements/, options_dodaj);
  });
</script>
<p>V tem primeru je razred <code>Lev</code> izjavil, da bo implementiral oz. opisal vedenja, ki so zahtevana v vmesniku - v tem primeru gre za metode <code>premikaj</code>, <code>govori</code> in <code>jej</code>. Vse metode morajo biti v razredu izrecno deklarirane in implementirane.</p>
<p>Vmesnik v programskem jeziku Java lahko opiše pričakovano skupno vedenje več razredov, brez da bi to vedenje neposredno implementiral. Vmesnik lahko implementira več razredov, kjer vsak razred, ki vmesnik implementira, definira lastno različico vedenja. Poleg tega lahko razred implementira tudi več različnih vmesnikov.</p>
<p>Vmesnike lahko na UML razrednih diagramih narišemo na podoben način kot razrede, kar prikazuje slika <a href="P9.html#fig:RD-vmesnik#fig:RD-vmesnik">16.10</a>. Vmesniki so izrecno označeni s stereotip v obliki <code>«interface»</code>.</p>

<div class="figure" style="text-align: center"><span style="display:block;" id="fig:RD-vmesnik"></span>
<img src="../../plantuml/svg/HOmx3i8m44JxFSKA2aw0H16b80A92z1lx8LO_g5TXnI8ksEm5CfvysRKk_GWeOWca2g-074au--IvsI77BBWChd2Nvx5iZIstP-FXzDGAOdafS4nr2MyGTVJ_vNv6KKeQQqu5O3Tv2nZv3YoA81BXUL6Xd63byZuZAp9UQgH5AyjOTUjNjz_0000" alt="Primer vmesnika PlantUML" width="140" />
<p class="caption">
Slika 16.10: Primer vmesnika <a href="https://teaching.lavbic.net/plantuml/uml/HOmx3i8m44JxFSKA2aw0H16b80A92z1lx8LO_g5TXnI8ksEm5CfvysRKk_GWeOWca2g-074au--IvsI77BBWChd2Nvx5iZIstP-FXzDGAOdafS4nr2MyGTVJ_vNv6KKeQQqu5O3Tv2nZv3YoA81BXUL6Xd63byZuZAp9UQgH5AyjOTUjNjz_0000"><small><i class='fas fa-project-diagram' style='padding-right:4px'></i>PlantUML</small></a>
</p>
</div>
<p>Interakcija med vmesnikom in razredom, ki implementira vmesnik, je označena s prekinjeno puščico. Na začetku puščice se nahaja razred, ki vmesnik implementira, na vrhu puščice pa je vmesnik. Ponavadi vmesnike na razrednih diagramih rišemo tako, da je puščica usmerjena navzgor, kjer je vmesnik zgoraj, razredi, ki ga implementirajo pa spodaj, kot prikazuje slika <a href="P9.html#fig:RD-vmesnik-razred#fig:RD-vmesnik-razred">16.11</a>.</p>

<div class="figure" style="text-align: center"><span style="display:block;" id="fig:RD-vmesnik-razred"></span>
<img src="../../plantuml/svg/POyz3i8m38LdSWghB23KRaWCLGSgE003kziQ24sJoacfnCzTE0id8n0e0_9YVxRVisqjTOkC3PGAhOMB02YmhFTiEbtbHXc6_Y0TlRZXYZYmyNozNAnoJv7Pz04Moc-Acx23w4-gV4yuHcrzYxGJGcf7lCEI889jGrRBscTeXo9DXv4iywUDuZZsZW2pYfGveJxIPFgu_uU_8RmJ0Mpmp5H1K0w541-OT6ropRv-Jm00" alt="Primer razreda, ki implementira vmesnika PlantUML" width="140" />
<p class="caption">
Slika 16.11: Primer razreda, ki implementira vmesnika <a href="https://teaching.lavbic.net/plantuml/uml/POyz3i8m38LdSWghB23KRaWCLGSgE003kziQ24sJoacfnCzTE0id8n0e0_9YVxRVisqjTOkC3PGAhOMB02YmhFTiEbtbHXc6_Y0TlRZXYZYmyNozNAnoJv7Pz04Moc-Acx23w4-gV4yuHcrzYxGJGcf7lCEI889jGrRBscTeXo9DXv4iywUDuZZsZW2pYfGveJxIPFgu_uU_8RmJ0Mpmp5H1K0w541-OT6ropRv-Jm00"><small><i class='fas fa-project-diagram' style='padding-right:4px'></i>PlantUML</small></a>
</p>
</div>
<p>Vmesniki prinašajo številne prednosti. Razumevanje, kaj predstavlja, pomaga pri ugotavljanju ali moramo pri načrtovanju sistema uporabiti vmesnike ali dedovanje.</p>
<p>Tako kot <strong>abstraktni razredi</strong> <em>(angl. <a href="https://en.wikipedia.org/wiki/Abstract_type"><i class="fa-brands fa-wikipedia-w"></i>abstract classes</a>)</em>, ki jih ni mogoče instancirati, so vmesniki ena izmed možnosti, da dosežemo <strong>polimorfizem</strong> <em>(angl. <a href="https://en.wikipedia.org/wiki/Polymorphism_(computer_science)"><i class="fa-brands fa-wikipedia-w"></i>polymorphism</a>)</em>. V objektno usmerjenih programskih je jezikih govorimo o polimorfizmu takrat, ko imata dva razreda enak opis vedenja, vendar sta implementaciji lahko različni. Primer tega je lahko način “govora” živali. Lev lahko rjovi, vendar volk tuli. Obe živali lahko govorita, vendar je implementacija drugačna.</p>
<p>To lahko prikažemo na spodnjem primeru:</p>
<p><code>Lev.java</code></p>
<div class="sourceCode" id="Lev-polimorfizem"><pre class="sourceCode java"><code class="sourceCode java"><span id="Lev-polimorfizem-1"><a href="P9.html#Lev-polimorfizem-1" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> Lev <span class="kw">implements</span> IZival <span class="op">{</span></span>
<span id="Lev-polimorfizem-2"><a href="P9.html#Lev-polimorfizem-2" tabindex="-1"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">govori</span><span class="op">()</span> <span class="op">{</span></span>
<span id="Lev-polimorfizem-3"><a href="P9.html#Lev-polimorfizem-3" tabindex="-1"></a>    <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Rjovenje!&quot;</span><span class="op">);</span></span>
<span id="Lev-polimorfizem-4"><a href="P9.html#Lev-polimorfizem-4" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="Lev-polimorfizem-5"><a href="P9.html#Lev-polimorfizem-5" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><code>Volk.java</code></p>
<div class="sourceCode" id="Volk-polimorfizem"><pre class="sourceCode java"><code class="sourceCode java"><span id="Volk-polimorfizem-1"><a href="P9.html#Volk-polimorfizem-1" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> Volk <span class="kw">implements</span> IZival <span class="op">{</span></span>
<span id="Volk-polimorfizem-2"><a href="P9.html#Volk-polimorfizem-2" tabindex="-1"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">govori</span><span class="op">()</span> <span class="op">{</span></span>
<span id="Volk-polimorfizem-3"><a href="P9.html#Volk-polimorfizem-3" tabindex="-1"></a>    <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Zavijanje!&quot;</span><span class="op">);</span></span>
<span id="Volk-polimorfizem-4"><a href="P9.html#Volk-polimorfizem-4" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="Volk-polimorfizem-5"><a href="P9.html#Volk-polimorfizem-5" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<script>
  $(document).ready(function() {
    $("#Lev-polimorfizem").markRegExp(/\s+?public void govori[\s\S]+?}/, options_dodaj);
    $("#Volk-polimorfizem").markRegExp(/\s+?public void govori[\s\S]+?}/, options_dodaj);
  });
</script>
<p>Vmesniki lahko podedujejo druge vmesnike, vendar vmesnikov ne moremo razširiti, če bi preprosto želeli kreirati večji vmesnik. Vmesnik A bi moral podedovati od vmesnika B samo, če je vedenje v vmesniku A mogoče v celoti uporabit kot nadomestek za vmesnik B.</p>
<p>Za predstavitev tega koncepta si poglejmo spodnji primer.</p>
<p><code>IGibanjeVozila.java</code></p>
<div class="sourceCode" id="cb162"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb162-1"><a href="P9.html#cb162-1" tabindex="-1"></a><span class="kw">public</span> interace IGibanjeVozila <span class="op">{</span></span>
<span id="cb162-2"><a href="P9.html#cb162-2" tabindex="-1"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">premakniNaX</span><span class="op">();</span></span>
<span id="cb162-3"><a href="P9.html#cb162-3" tabindex="-1"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">premakniNaY</span><span class="op">();</span></span>
<span id="cb162-4"><a href="P9.html#cb162-4" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>V primeru lahko vozilo potuje samo vzdolže osi X ali osi Y. Kaj pa, če bi potrebovali še druge vrste vozil, kot je npr. letalo ali podmornica, ki se lahko premika tudi po tretji osi Z? Da bi se izognili dodajanju vedenja obstoječemu vmesniku in s tem vplivu na vozila, ki se lahko premikajo zgolj vzdolž dveh osi, ustvarimo nov vmesnik, ki deduje prvega.</p>
<p><code>IGibanjeVozila3D.java</code></p>
<div class="sourceCode" id="cb163"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb163-1"><a href="P9.html#cb163-1" tabindex="-1"></a><span class="kw">public</span> <span class="kw">interface</span> IGibanjeVozila3D <span class="kw">extends</span> IGibanjeVozila <span class="op">{</span></span>
<span id="cb163-2"><a href="P9.html#cb163-2" tabindex="-1"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">premakniNaZ</span><span class="op">();</span></span>
<span id="cb163-3"><a href="P9.html#cb163-3" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Druga prednost vmesnikov se nanaša na dedovanje več implementacij. Dedovanje iz dveh ali več razredov lahko namreč povzroči <strong>dvoumnost podatkov</strong> <em>(angl. data <a href="https://en.wikipedia.org/wiki/Ambiguity"><i class="fa-brands fa-wikipedia-w"></i>ambiguity</a>)</em> - če imamo atribute z enakim imenom ali vedenja z istim imenom metod, med njimi ne moremo razlikovati. Da preprečimo dvoumnost podatkov, programski jezik Java ne dovoljuje večkratnega dedovanja.</p>
<p>Vmesniki pa teh težav nimajo in v programskem jeziku Java lahko razred implementira poljubno število vmesnikov. Vmesniki so namreč zgolj pogodbe in ne uveljavljajo posebnega načina za implementacijo pogodb, zato prekrivajoča imena metodo ne predstavljajo težavo. Sprejemljiva je namreč zgolj ena implementacija metode, ki bi se morebiti prekrivala med različnimi vmesniki. Pri tem dvoumnosti ni, saj ima lahko razred zgolj eno definicijo določene metode in je implementirana ne glede na vmesnik. V programskem jeziku Java se na ta način izognemu dvoumnosti podatkov.</p>
<p>Razredi lahko implementirajo enega ali več vmesnikov hkrati, kar omogoča več tipov. Vmesnika omogočajo opisovanje vedenja, brez da bi ga implementirali, kar dovoljuje ponovno uporabo teh abstrakcij. Z vmesniki lahko razvijemo programe z večjo stopnjo ponovne uporabe in prilagodljivosti. Pomembno pa je vedeti, da v vmesnikih vseh vedenj ne moremo posplošiti. Vmesniki zadovoljujejo posebno potrebo, in sicer zagotavljajo način za doseldno delo povezanih razredov.</p>
</div>
</div>
</div>
</div>
<div id="načrtovalska-načela" class="section level2 hasAnchor" number="16.3">
<h2><span class="header-section-number">16.3</span> Načrtovalska načela<a href="P9.html#načrtovalska-načela" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>V okviru tega poglavja bomo predstavili splošne smernice za ocenjevanje strukture programske rešitve. Te smernice nam pomagajo zagotoviti, da je programska oprema prilagodljiva, ponovno uporabna in ima visoko stopnjo vzdrževalnosti. Predstavili bomo tudi obnašanje objektov v programski opremi z uporabo UML diagramov stanja in UML diagramov zaporedja.</p>
<div id="vrednotenje-kompleksnosti-načrta" class="section level3 hasAnchor" number="16.3.1">
<h3><span class="header-section-number">16.3.1</span> Vrednotenje kompleksnosti načrta<a href="P9.html#vrednotenje-kompleksnosti-načrta" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Pri programiranju je pomembno, da so moduli preprosti. Če kompleksnost načrta presega tisto, kar so razvijalci sposobni razumeti, se bodo napake pojavljale pogosteje. Da bi to lažje nadzorovali, moramo uporabiti nek način vrednotenja kompleksnosti načrta.</p>
<p>Kompleksnost načrtovanja se ukvarja tako z razredi kot njihovimi metodami. V okviru tega poglavja bomo uporabili izraz <strong>modul</strong> za programske enote, ki vsebujejo razrede in znotraj njih metode.</p>
<p>Sistem je kombinacija različnih modulov. Če je sistem slabo zasnovan, se lahko moduli povežejo samo z drugimi specifičnimi moduli in nič drugega. Dober načrt omogoča enostavno povezovanje vseh modulov, kar pomeni, da so moduli medsebojno združljivi in jih je zato mogoče preprosto povezati in ponovno uporabiti.</p>
<p><strong>Sklopljenost</strong> <em>(angl. <a href="https://en.wikipedia.org/wiki/Coupling_(computer_programming)"><i class="fa-brands fa-wikipedia-w"></i>coupling</a>)</em> in <strong>kohezija</strong> <em>(angl. <a href="https://en.wikipedia.org/wiki/Cohesion_(computer_science)"><i class="fa-brands fa-wikipedia-w"></i>cohesion</a>)</em> sta metriki, ki se pogosto uporabljata za ocenjevanje kompleksnosti načrtovanja.</p>
<div id="sklopljenost" class="section level4 hasAnchor" number="16.3.1.1">
<h4><span class="header-section-number">16.3.1.1</span> Sklopljenost<a href="P9.html#sklopljenost" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p><strong>Sklopljenost</strong> <em>(angl. <a href="https://en.wikipedia.org/wiki/Coupling_(computer_programming)"><i class="fa-brands fa-wikipedia-w"></i>Coupling</a>)</em> se osredotoča na kompleksnost med modulom in drugimi moduli. Sklopljenost oz. povezanost lahko obravnavamo med dvema skrajnostima: tesna sklopljenost <em>(angl. tight coupling)</em> in šibka sklopljenost <em>(angl. loose coupling)</em>. Če je modul preveč odvisen od drugih modulov, potem je <strong>tesno sklopljen</strong> z drugimi moduli, kar je primer slabega načrta. Če pa se modul zlahka poveže z drugimi moduli preko opredeljenih vmesnikov, je <strong>šibko sklopljen</strong> z drugimi, kar je primer dobrega načrta.</p>
<p>Pri vrednotenju sklopljenosti modula je treba upoštevati naslednje metrike: <strong>stopnjo</strong> <em>(angl. degree)</em>, <strong>enostavnost</strong> <em>(angl. ease)</em> in <strong>prilagodljivost</strong> <em>(angl. flexibility)</em>.</p>
<p><strong>Stopnja</strong> predstavlja število povezav med modulom in drugimi moduli. Z vidika sklopljenosti mora biti takšna stopnja majhna. Primer majhne stopnje in ohlapne povezave imamo takrat, ko se mora modul povezati z drugimi preko le nekaj parametrov ali z enostavnimi vmesniki.</p>
<p><strong>Enostavnost</strong> predstavlja, kako očitne so povezave med modulom in drugimi moduli. Povezave morajo biti enostavne za vzpostavitev, brez da je treba za namene povezovanja razumevanje izvedbe drugih modulov.</p>
<p><strong>Prilagodljivost</strong> prikazuje, kako zamenljivi so drugi moduli z vidika izbranega modula. Druge module mora biti v prihodnosti, za potrebe sklopljenosti, enostavno zamenjati za nekaj boljšega.</p>
<p>Znaki, da je sistem tesno povezan in ima slabo zasnovo, so:</p>
<ul>
<li>modul se povezuje z drugimi moduli preko velikega števila parametrov ali vmesnikov,</li>
<li>težko je najti module, ki ustrezajo modulu,</li>
<li>module je mogoče povezati samo z določenimi drugimi moduli in jih ni mogoče zamenjati.</li>
</ul>
</div>
<div id="kohezija" class="section level4 hasAnchor" number="16.3.1.2">
<h4><span class="header-section-number">16.3.1.2</span> Kohezija<a href="P9.html#kohezija" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p><strong>Kohezija</strong> <em>(angl. <a href="https://en.wikipedia.org/wiki/Cohesion_(computer_science)"><i class="fa-brands fa-wikipedia-w"></i>Cohesion</a>)</em> se osredotoča na kompleksnost znotraj modula in predstavlja jasnost odgovornosti modula. Tudi kohezija nastopa med dvema skrajnostima: <strong>visoka kohezija</strong> <em>(angl. high cohesion)</em> in <strong>nizka kohezija</strong> <em>(angl. low cohesion)</em>.</p>
<p>Modul, ki opravlja zgolj eno nalogo in nič drugega ali ima opredeljen jasen namen, ima visoko kohezijo. Dober načrt je povezan z visoko kohezijo. Po drugi strani pa ima modul nizko kohezijo, če enkapsulira več namenov, če je potrebno razbijanje enkapsulacije, da bi razumeli metodo ali je namen modula nejasen. Slab načrt je povezan z nizko kohezijo. Če ima modul več kot eno odgovornost, je smiselno takšen modul razdeliti.</p>
<p>Pri načrtovanju sistema je pomembno uravnotežiti šibko sklopljenost in visoko kohezijo. Pri dobrem načrtu namreč potrebujemo oboje. Vendar pa je v kompleksnih sistemih le-ta porazdeljena med module ali znotraj modulov. Če so npr. moduli zasnovi za doseganje visoke kohezije, bodo verjetno morali biti odvisni od drugih modulov, kar poveča sklopljenost. Po drugi strani, če imamo poenostavljene povezave med moduli, da dosežemo šibko sklopljenost, bodo moduli verjetno morali prevzeti več odgovornosti in tako se zmanjša kohezija.</p>
</div>
</div>
<div id="načelo-ločevanja-pomislekov" class="section level3 hasAnchor" number="16.3.2">
<h3><span class="header-section-number">16.3.2</span> Načelo ločevanja pomislekov<a href="P9.html#načelo-ločevanja-pomislekov" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>V okviru predavanja smo obravnavali tudi razgradnjo <em>(angl. decomposition)</em>, ki razdeli celoto na različne dele. Da bi razumeli, zakaj je razgradnja pri načrtovanju potrebna, moramo predstaviti <strong>načelo ločevanja skrbi</strong> <em>(angl. <a href="https://en.wikipedia.org/wiki/Separation_of_concerns"><i class="fa-brands fa-wikipedia-w"></i>separation of concerns</a>)</em>.</p>
<p><strong>Pomislek</strong> <em>(angl. Concern)</em> je zelo splošen pojem: lahko predstavlja vse, kar je pomembno pri zagotavljanju rešitve problema. Ločevanje skrbi pomeni, da različne pomisleke v začetni zasnovi medsebojno ločimo. Ko je programska oprema zasnovana, je treba v različnih delih programske opreme obravnavati različne pomisleke.</p>
<p>Recimo, da imamo računalniški sistem, ki rešuje problem. Ta problem je lahko preprost, z večjim številom podproblemov. Koncepte lahko iz problemskega prostora pridobimo s pomočjo abstrakcije. Ko bodo te abstrakcije implementirane v programski rešitvi, lahko to povzroči več pomislekov. Nekateri izmed pomislekov se lahko ukvarjajo z vidikom, katere informacije predstavlja implementacija, s katerimi podatki manipulira in kaj se na koncu predstavi. Da se ne izgubimo v posledičnih pomislekih in podproblemih, je treba načrtovanje organizirati tako, da so vse pomisleke skrbno pretehtamo in obravnavamo. Če želimo to doseči, bomo med načrtovanje različne podprobleme in pomisleke ločili v različne kategorije. To je osnovna ideja ločevanja pomislekov.</p>
<p>Ločevanje pomislekov ima številne prednosti, saj nam omogoča neodvisen razvoj in posodabljanje delov programske opreme. Uporaba ločevanja pomislekov pomeni tudi, da nam ni treba vedeti, kako delujejo vsi deli kode, da lahko posodobimo določen del kode. Nazadnje, ločevanje pomislekov omogoča spreminjanje ene komponente, ne da bi bilo treba spremeniti drugo.</p>
<p>Ločevanje pomislekov je osnova objektno usmerjenega načrtovanja in programiranja. Pri ločeni obravnavi pomislekov nastanejo bolj kohezivni razredi in se uveljavljajo načrtovalska načela abstrakcije, ovijanja, razgradnje in posploševanja:</p>
<ul>
<li>Do <strong>abstrakcije</strong> <em>(angl. abstraction)</em> pride, ko je vsak koncept v problemskem prostoru ločen s svojimi atributi in vedenji.</li>
<li><strong>Ovijanje</strong> <em>(angl. encapsulation)</em> se pojavi, ko se atributi in vedenja zberejo v lastnem delu kode, ki ga imenujemo razred. Dostop do razreda s strani preostalega dela sistema in implementacija razreda sta ločena, tako da se podrobnosti implementacije lahko spreminjajo, pogled skozi vmesnik pa ostane enak.</li>
<li><strong>Razgradnja</strong> <em>(angl. decomposition)</em> se zgodi, ko lahko celoten razred ločimo na več razredov.</li>
<li>Do <strong>posplošitve</strong> <em>(angl. generalization)</em> pride, ko prepoznamo skupne lastnosti in jih nato ločimo in posplošimo v nadrazred.</li>
</ul>
<p>Ločevanje pomislekov se stalno izvaja v celoten procesu načrtovanja sistema. Zaradi povezave med ločevanjem pomislekov in načrtovalski načeli, uporaba tega koncepta pri načrtovanju pripelje do sistema, ki ga je lažje vzdrževati, ker je vsak razred organiziran tako, da vsebuje samo kodo, ki je potreba za opravljanje njegovega dela. Modularnost se posledično poveča, kar razvijalcem omogoča ponovno uporabo in razvoj posameznih razredov, brez vpliva na druge.</p>
<p>Pomembno je tudi izpostaviti, da meje vsakega razreda v praksi niso vedno očitne. Odločitev, o tem kako se lotiti abstrakcije, oviti, razstaviti in posplošitvi, kjer upoštevamo številne pomisleke, predstavlja osnovo načrtovanja modularne programske opreme.</p>
<div id="primer-locevanja-pomislekov" class="section level4 hasAnchor" number="16.3.2.1">
<h4><span class="header-section-number">16.3.2.1</span> Primer ločevanja pomislekov<a href="P9.html#primer-locevanja-pomislekov" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Sedaj si na primeru pametnega telefona oglejmo načelo ločevanja pomislekov. Pametni telefoni so sposobni različnih vedenj: fotografiranja, načrtovanja sestankov, pošiljanja e-pošte, brskanja po internetu, pošiljanja sporočil in telefoniranja. Zaradi enostavnosti se bomo osredotočili zgolj na dve funkcionalnosti: uporabo kamere in tradicionalne funkcionalnosti telefona.</p>
<p><code>PametniTelefon.java</code></p>
<div class="sourceCode" id="cb164"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb164-1"><a href="P9.html#cb164-1" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> PametniTelefon <span class="op">{</span></span>
<span id="cb164-2"><a href="P9.html#cb164-2" tabindex="-1"></a>  <span class="kw">private</span> <span class="dt">byte</span> kamera<span class="op">;</span></span>
<span id="cb164-3"><a href="P9.html#cb164-3" tabindex="-1"></a>  <span class="kw">private</span> <span class="dt">byte</span> telefon<span class="op">;</span></span>
<span id="cb164-4"><a href="P9.html#cb164-4" tabindex="-1"></a>  <span class="kw">public</span> <span class="fu">PametniTelefon</span><span class="op">()</span> <span class="op">{</span> <span class="kw">...</span> <span class="op">}</span></span>
<span id="cb164-5"><a href="P9.html#cb164-5" tabindex="-1"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">fotografiraj</span><span class="op">()</span> <span class="op">{</span> <span class="kw">...</span> <span class="op">}</span></span>
<span id="cb164-6"><a href="P9.html#cb164-6" tabindex="-1"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">shraniSliko</span><span class="op">()</span> <span class="op">{</span> <span class="kw">...</span> <span class="op">}</span></span>
<span id="cb164-7"><a href="P9.html#cb164-7" tabindex="-1"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">uporabiBliskavico</span><span class="op">()</span> <span class="op">{</span> <span class="kw">...</span> <span class="op">}</span></span>
<span id="cb164-8"><a href="P9.html#cb164-8" tabindex="-1"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">telefoniraj</span><span class="op">()</span> <span class="op">{</span> <span class="kw">...</span> <span class="op">}</span></span>
<span id="cb164-9"><a href="P9.html#cb164-9" tabindex="-1"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">sifrirajOdhodniZvok</span><span class="op">()</span> <span class="op">{</span> <span class="kw">...</span> <span class="op">}</span></span>
<span id="cb164-10"><a href="P9.html#cb164-10" tabindex="-1"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">desifrirajDohodniZvok</span><span class="op">()</span> <span class="op">{</span> <span class="kw">...</span> <span class="op">}</span></span>
<span id="cb164-11"><a href="P9.html#cb164-11" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Izvorna koda vsebuje razred <code>PametniTelefon</code> z atributoma <code>kamera</code> in <code>telefom</code> ter povezanimi vedenji. Sistem ima nizko kohezijo, saj obstajajo vedenja, ki med seboj niso povezana. Da kamera opravi svoje delo ni potrebno vključiti vedenja kamera neposredno v vedenje telefona. Komponente tudi ne ponujajo modularnosti. Do kamere ali telefona npr. ni mogoče ločeno dostopati, če bi zgradili nov sistem, ki bi zahteval zgolj eno ali drugo. Fotoaparata tudi ne moremo zamenjati z drugim fotoaparatom ali celo drugim objektom, brez da popolnoma odstranimo kodo fotoaparata iz tega razreda.</p>
<p>Razred <code>PametniTelefon</code> bi moral biti bolj koheziven in vsaka komponenta pametnega telefona bi morala imeli svoje lastne funkcionalnosti. Z ločevanjem pomislekov lahko ugotovimo, da ima razred <code>PametniTelefon</code> dva pomisleka:</p>
<ol style="list-style-type: decimal">
<li>Delovanje kot klasičen telefon.</li>
<li>Fotografiranje z vgrajenim fotoaparatom.</li>
</ol>
<p>Pomisleke bi lahko ločili v lastne bolj kohezivne razrede, kjer bi vsak zajel podrobnosti določene pomisleka v funkcionalno ločene in neodvisne razrede.</p>
<p>Razred <code>PametniTelefon</code> bi se skliceval na primerke novih razredov tako, da lahko pametni telefon deluje kot koordinator kamere in telefona. Tako bo naš pametni telefon omogočil dostop do vseh vedenj kamere in telefona, ne da bi morali vedeti, kako se vsaka komponenta obnaša.</p>
<p>Z uporabo UML razrednega diagrama bi zasnova sistema pametna telefona lahko izgledala tako, kot to prikazuje slika <a href="P9.html#fig:RD-PametniTelefon#fig:RD-PametniTelefon">16.12</a>.</p>

<div class="figure" style="text-align: center"><span style="display:block;" id="fig:RD-PametniTelefon"></span>
<img src="https://teaching.lavbic.net/plantuml/svg/TL4zJyCm4DtzAwooyA5sGq8T65eeGWnKWedjwbpQQn9VT7RI0VZlE7MRXBITx7ll-RtpdSl8bY1GQ9E3S_fRQRq2aws5AvlCEMVHkmrvR72M12LYL_UBsSFpFA0Wmhi8hlBmKlqgrvfsLcQly0BM1GgjLoecBg50R-aJSqpPxXiO5xnTi6TeJFnKltR5WJse0tMuXLIo7YK5WosuDxlpiI21xVNDLDTCIGCxIgN1tfCD9vQ-QixwT897mHEV2lwbTTt5m3JKQu7q974JVayVEMNSXwkI1LOqoybbK9FXNaeSqKY_XPDCDwMH1ZS4Mt7Npr9gV46B0eQs65zTOfKQXaogSlBps8tuekzHs5jJku9nLOvl1qjM_P6T4_m1" alt="Ločevanje pomislekov na primeru pametnega telefona PlantUML" width="420" />
<p class="caption">
Slika 16.12: Ločevanje pomislekov na primeru pametnega telefona <a href="https://teaching.lavbic.net/plantuml/uml/TL4zJyCm4DtzAwooyA5sGq8T65eeGWnKWedjwbpQQn9VT7RI0VZlE7MRXBITx7ll-RtpdSl8bY1GQ9E3S_fRQRq2aws5AvlCEMVHkmrvR72M12LYL_UBsSFpFA0Wmhi8hlBmKlqgrvfsLcQly0BM1GgjLoecBg50R-aJSqpPxXiO5xnTi6TeJFnKltR5WJse0tMuXLIo7YK5WosuDxlpiI21xVNDLDTCIGCxIgN1tfCD9vQ-QixwT897mHEV2lwbTTt5m3JKQu7q974JVayVEMNSXwkI1LOqoybbK9FXNaeSqKY_XPDCDwMH1ZS4Mt7Npr9gV46B0eQs65zTOfKQXaogSlBps8tuekzHs5jJku9nLOvl1qjM_P6T4_m1"><small><i class='fa-solid fa-diagram-project'></i>PlantUML</small></a>
</p>
</div>
<p>Atributi in vedenja za telefon in kamero so ločeni v dveh različnih vmesnikih. Vsak od njih je implementiran z ustreznim razredom.</p>
<p><code>IFotoaparat.java</code></p>
<div class="sourceCode" id="cb165"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb165-1"><a href="P9.html#cb165-1" tabindex="-1"></a><span class="kw">public</span> <span class="kw">interface</span> IFotoaparat <span class="op">{</span></span>
<span id="cb165-2"><a href="P9.html#cb165-2" tabindex="-1"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">fotografiraj</span><span class="op">();</span></span>
<span id="cb165-3"><a href="P9.html#cb165-3" tabindex="-1"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">shraniSliko</span><span class="op">();</span></span>
<span id="cb165-4"><a href="P9.html#cb165-4" tabindex="-1"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">uporabiBliskavico</span><span class="op">();</span></span>
<span id="cb165-5"><a href="P9.html#cb165-5" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><code>ITelefon.java</code></p>
<div class="sourceCode" id="cb166"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb166-1"><a href="P9.html#cb166-1" tabindex="-1"></a><span class="kw">public</span> <span class="kw">interface</span> ITelefon <span class="op">{</span></span>
<span id="cb166-2"><a href="P9.html#cb166-2" tabindex="-1"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">telefoniraj</span><span class="op">();</span></span>
<span id="cb166-3"><a href="P9.html#cb166-3" tabindex="-1"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">sifrirajOdhodniZvok</span><span class="op">();</span></span>
<span id="cb166-4"><a href="P9.html#cb166-4" tabindex="-1"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">desifrirajDohodniZvok</span><span class="op">();</span></span>
<span id="cb166-5"><a href="P9.html#cb166-5" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><code>FotoaparatPrveGeneracije.java</code></p>
<div class="sourceCode" id="cb167"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb167-1"><a href="P9.html#cb167-1" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> FotoaparatPrveGeneracije <span class="kw">implements</span> IFotoaparat <span class="op">{</span></span>
<span id="cb167-2"><a href="P9.html#cb167-2" tabindex="-1"></a>  <span class="co">/* Abstrahirani atributi fotoaparata */</span></span>
<span id="cb167-3"><a href="P9.html#cb167-3" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><code>KlasicniTelefon.java</code></p>
<div class="sourceCode" id="cb168"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb168-1"><a href="P9.html#cb168-1" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> KlasicniTelefon <span class="kw">implements</span> ITelefon <span class="op">{</span></span>
<span id="cb168-2"><a href="P9.html#cb168-2" tabindex="-1"></a>  <span class="co">/* Abstrahirani aitributi telefona */</span></span>
<span id="cb168-3"><a href="P9.html#cb168-3" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Izvorno kodo razreda <code>PametniTelefon</code> bo prav tako treba preoblikovati, da referencira dva ločena razreda.</p>
<p><code>PametniTelefon.java</code></p>
<div class="sourceCode" id="cb169"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb169-1"><a href="P9.html#cb169-1" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> PametniTelefon <span class="op">{</span></span>
<span id="cb169-2"><a href="P9.html#cb169-2" tabindex="-1"></a>  <span class="kw">private</span> IFotoaparat<span class="op">:</span> mojFotoaparat<span class="op">;</span></span>
<span id="cb169-3"><a href="P9.html#cb169-3" tabindex="-1"></a>  <span class="kw">private</span> ITelefon<span class="op">:</span> mojTelefon<span class="op">;</span></span>
<span id="cb169-4"><a href="P9.html#cb169-4" tabindex="-1"></a>  <span class="kw">public</span> <span class="fu">PametniTelefon</span><span class="op">(</span>IFotoaparat fotoaparat<span class="op">,</span> ITelefon telefon<span class="op">)</span> <span class="op">{</span></span>
<span id="cb169-5"><a href="P9.html#cb169-5" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="fu">mojFotoaparat</span> <span class="op">=</span> fotoaparat<span class="op">;</span></span>
<span id="cb169-6"><a href="P9.html#cb169-6" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="fu">mojTelefon</span> <span class="op">=</span> telefon<span class="op">;</span></span>
<span id="cb169-7"><a href="P9.html#cb169-7" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb169-8"><a href="P9.html#cb169-8" tabindex="-1"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">uporabiFotoaparat</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb169-9"><a href="P9.html#cb169-9" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="fu">mojFotoaparat</span><span class="op">.</span><span class="fu">fotografiraj</span><span class="op">();</span></span>
<span id="cb169-10"><a href="P9.html#cb169-10" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb169-11"><a href="P9.html#cb169-11" tabindex="-1"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">uporabiTelefon</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb169-12"><a href="P9.html#cb169-12" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="fu">mojTelefon</span><span class="op">.</span><span class="fu">telefoniraj</span><span class="op">();</span></span>
<span id="cb169-13"><a href="P9.html#cb169-13" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb169-14"><a href="P9.html#cb169-14" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>S to prenovo razred <code>PametniTelefon</code> zagotavlja funkcije fotoaparata in telefona. Razreda fotoaparata in telefona sta ločena, zato sta funkciji skriti drug pred drugim, vendar sta še vedno združeni v razredu pametnega telefona. Na voljo imamo konstruktor razreda <code>PametniTelefon</code>, kjer sta fotoaparat in kamera parametra. Tako lahko kreiramo nov primerek razreda <code>PametniTelefon</code> s posredovanjem primerkov razredov, ki implementirajo vmesnika <code>ITelefon</code> in <code>IFotoaparat</code>. Kreiranje ustreznih objektov telefona in fotoaparat je ločena odgovornost, saj razredu <code>PametniTelefon</code> tega ni treba vedeti. Končno ima razred <code>PametniTelefon</code> metode, ki posredujejo odgovornosti uporabe kamere in telefona tem razredom.</p>
<p>S tem dosežemo modularno zasnovo: če pride kasneje do zahteve po zamenjavi razreda fotoaparata ali telefona, spremembe v izvorni kodi razreda <code>PametniTelefon</code> niso potrebne. Koda se preprosto spremeni do te mere, da se kreira primerek pametnega telefona in njegovih delov.</p>
<p>Razred <code>PametniTelefon</code> ima sedaj višjo kohezijo, vendar je po drugi strani bolj tesno sklopljen, saj mora razred <code>PametniTelefon</code> poznati vmesnika <code>IFotoaparat</code> in <code>ITelefon</code> ter je posredno odvisen od drugih razredov.</p>
<p>V tem primeru smo ločevanje pomislekov uporabili za:</p>
<ul>
<li>ločevanje pojmov fotoaparata in telefona z uporabo posploševanja in opredelitvijo obeh vmesnikov,</li>
<li>ločevanje funkcionalnosti fotoaparata prve generacije in klasičnega telefona z uporabo abstrakcije in ovijanja ter vpeljave dveh razredov z implementacijo vmesnika,</li>
<li>uporabo razgradnje <em>(angl. decomposition)</em> na pametnem telefoni, tako da so sestavni deli ločeni od celote.</li>
</ul>
</div>
</div>
<div id="skrivanje-informacij" class="section level3 hasAnchor" number="16.3.3">
<h3><span class="header-section-number">16.3.3</span> Skrivanje informacij<a href="P9.html#skrivanje-informacij" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Dobro zasnovan načrt je dobro organiziran, kar dosežemo s pomočjo različnih načrtovalskih načel. V okviru tega poglavja bomo podrobneje predstavili koncept dostop do informacij. Vsaki komponenti sistema ni treba poznati vsega o vseh drugih elementih. Moduli morajo imeti dostop samo do informacij, ki jih potrebujejo za opravljanje svojega dela. <strong>Skrivanje informacij</strong> <em>(angl. information hiding)</em> je omejitev informacij na module z namenom minimalne potrebne količine informacij za pravilno delovanje in skrivanje preostalega dela.</p>
<p>Skrivanje informacij je ponavadi povezano z občutljivimi podatki - bolj kot so podatki občutljivi, večja je verjetnost, da bi morali imeti omejen dostop. Pri načrtovanju programske opreme se skrivanje informacij uporablja tudi za skrivanje podrobnosti, ki se spreminjajo, npr. algoritmi ali predstavitve podatkov. Po drugi strani pa predpostavk ne skrivamo in so običajno izpostavljene v obliki API-jev in vmesnikov.</p>
<p>Skrivanje informacij razvijalcem omogoča ločeno delo na modulih, brez da bi morali drugi razvijalci poznati podrobnosti implementacije modula, na katerem delajo. Namesto tega se modul uporablja preko njegovega vmesnika.s</p>
<p>Dobro osnovno pravilo se glasi, da morajo biti elementi, ki se lahko spremenijo (npr. podrobnosti implementacije), skrite, elementi, ki se ne spreminjajo (npr. predpostavke), pa so izpostavljeni preko vmesnikov.</p>
<p>Skrivanje informacij je tesno povezano z ovijanjem <em>(angl. encapsulation)</em>, ki združuje atribute in vedenja v ustrezne razrede ter se ukvarja tudi z zagotavljanjem dostopa do modulov preko vmesnikov in omejevanjem dostopa do določenih funkcij. Ker je s pomočjo ovijanja implementacija vedenja skrita za vmesnikom, ki je edini način za dostop do določenih metod, se drugi razredi zanašajo na informacije opredelitve metod in ne na osnovne implementacije. Skrivanje informacij preko ovijanja omogoča spremembo implementacije brez spremembe pričakovanega rezultata. Pričkovanja glede vedenja so izpolnjena, brez da razkrijemo, kako je to doseženo.</p>
<p>Poleg skrivanja implementacije ali vedenja je mogoče skriti tudi atribute. To preprečuje neposredno spreminjanje kritičnih informacij razred. Npr. če je atribut ključen za vsa vedenja razreda, potem ne želimo, da bi ga zunanji razredi neposredno spreminjali.</p>
<p>Skrivanje informacij lahko dosežemo z uporabo <strong>modifikatorjev dostopa</strong> <em>(angl. <a href="https://en.wikipedia.org/wiki/Access_modifiers"><i class="fa-brands fa-wikipedia-w"></i>access modifiers</a>)</em>, ki spremenijo, kateri razredi lahko dostopajo do atributov in vedenj. Določajo tudi, katere atribute in vedenja bo nadrazred delil s svojimi podrazredi. V programskem jeziku Java so na voljo štiri ravni dostopa:</p>
<ul>
<li>javno <em>(angl. public)</em>,</li>
<li>zaščiteno <em>(angl. protected)</em>,</li>
<li>privzeto <em>(angl. default)</em> in</li>
<li>zasebno <em>(angl. private)</em>.</li>
</ul>
<div id="javno" class="section level4 hasAnchor" number="16.3.3.1">
<h4><span class="header-section-number">16.3.3.1</span> Javno<a href="P9.html#javno" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Atribut z modifikatorjem <strong>javnega</strong> <em>(angl. public)</em> dostopa so dostopni kateremo koli razredu v sistemu. To pomeni, da lahko drugi razredi pridobijo in spremenijo vrednost atributa. Metodam tudi lahko dodelimo javno raven dostopa, tako da lahko kateri koli razred v sistemu dostopa do metode. Vendar pa takšen dostop ne dovoljuje drugim razredom spreminjanja implementacije vedenja metode. Javno dostopna metoda preprosto dovoljuje drugim razredom, da metodo pokličejo in prejmejo odgovor. Zaradi ovijanja <em>(angl. encapsulation)</em> pa je implementacija metode še vedno skrita.</p>
</div>
<div id="zaščiteno" class="section level4 hasAnchor" number="16.3.3.2">
<h4><span class="header-section-number">16.3.3.2</span> Zaščiteno<a href="P9.html#zaščiteno" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Atributi in metode, ki so <strong>zaščitene</strong> <em>(angl. protected)</em> niso dostopni vsakemu razredu sistema. Namesto tega so na voljo le enkapsuliranemu razredu, vsem podrazredom in razredom znotraj istega paketa. Paketi so sredstva, s katerimi v programskem jeziku Java organiziramo povezane razrede v en sam imenski prostor.</p>
</div>
<div id="privzeto" class="section level4 hasAnchor" number="16.3.3.3">
<h4><span class="header-section-number">16.3.3.3</span> Privzeto<a href="P9.html#privzeto" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p><strong>Privzeti</strong> <em>(angl. Default)</em> modifikator dostopa dovoljuje dostop do atributov in metod samo podrazredom ali razredom, ki so del istega paketa ali enkapsulacije. Ta modifikator dostopa poznamo tudi kot dostop brez modifikatorja, ker ga ni treba izrecno navesti v izvorni kodi.</p>
</div>
<div id="zasebno" class="section level4 hasAnchor" number="16.3.3.4">
<h4><span class="header-section-number">16.3.3.4</span> Zasebno<a href="P9.html#zasebno" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Atributi in metode, ki so <strong>zasebni</strong> <em>(angl. private)</em>, niso dostopni nobenemu drugemu razredu, razem enkapsulacijskemu razredu. To pomeni, da do teh atributov ni mogoče neposredno dostopati in teh metode ne morejo poklicati nobeni drugi razredi.</p>
<p>Naslednji primer izvorne kode prikazuje, kako lahko navedemo modifikator dostopa.</p>
<p><code>Oseba.java</code></p>
<div class="sourceCode" id="cb170"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb170-1"><a href="P9.html#cb170-1" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> Oseba <span class="op">{</span></span>
<span id="cb170-2"><a href="P9.html#cb170-2" tabindex="-1"></a>  <span class="bu">String</span> ime<span class="op">;</span></span>
<span id="cb170-3"><a href="P9.html#cb170-3" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>V tem primeru smo za razred <code>Oseba</code> uporabili javni modifikator dostopa <code>public</code>, spremenljivka <code>ime</code> pa ima nastavljen privzeti <code>default</code> dostop, ker ni navedenega nobenega modifikatorja. Pri spremenljivki <code>ime</code> bi lahko uporabili tudi modifikatorja dostopa <code>protected</code> ali <code>private</code> za določitev drugačnega načina dostopa.</p>
</div>
</div>
<div id="konceptualna-celovitost" class="section level3 hasAnchor" number="16.3.4">
<h3><span class="header-section-number">16.3.4</span> Konceptualna celovitost<a href="P9.html#konceptualna-celovitost" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p><strong>Konceptualna celovitost</strong> <em>(angl. Conceptual integrity)</em> je koncept, povezan z izdelavo skladne programske opreme in vključuje sprejemanje odločitev o načrtu in implementaciji sistema tako da, tudi v primeru večje razvojne skupine, se zdi pristop koheziven in dosleden, kot da bi delo opravljal zgolj en član. To se običajno doseže z dogovorom o uporabi določenih načrtovalskih načel in dogovorov pri izdelavi sistema.</p>
<p>Pomembno je, da se konceptualne celovitosti ne zamenja z neupoštevanjem mnenja posameznih članov razvojne skupine, saj je treba o načrtu ves čas odkrito razpravljati.</p>
<p>Obstaja več načinov doseganja konceptualne celovitosti, in sicer:</p>
<ul>
<li>komunikacija,</li>
<li>pregledi izvorne kode,</li>
<li>uporaba določenih načrtovalskih načel in programski konstruktov,</li>
<li>imeti dobro opredeljen načrt in arhitekturo, na kateri temelji programska rešitev,</li>
<li>poenotenje pojmov,</li>
<li>majhna osrednja skupina, ki potrjuje vse doprinose oz. uveljavitve v okviru projekta.</li>
</ul>
<p>Učinkovita komunikacija ohranja konceptualno celovitost in omogoča članom razvojne skupine razpravo o uporabi določenih knjižnic ali metod pri obravnavi določenih vprašanj. To pomaga pri razvoju bolj dosledne kode. Nekatere dobre prakse za spodbujanje komunikacije vključujejo agilne razvojne pristope, kot so dnevni sestanki in retrospektive sprinta.</p>
<p><strong>Pregledi code</strong> <em>(angl. <a href="https://en.wikipedia.org/wiki/Code_review"><i class="fa-brands fa-wikipedia-w"></i>code reviews</a>)</em> so sistematični pregledi razvite izvorne kode in so zelo podobni strokovnim pregledom v akademskem okolju. Razvijalci pregledajo izvorno kodo vrsitco po vrstico in odkrivajo potencialne težave v izvorni kodi, ki so jo napisali drugi. To pomaga prepoznati napake in izboljšuje skladnost izvorne kode različnih razvijalcev.</p>
<p>Uporaba določenih načrtovalskih načel in programskih konstruktov tudi pomaga ohraniti konceptualno celovitost. Predvsem vmesniki so eden takšnih konstruktov, ki nam pri tem pomagajo. Vmesnik opredeli tip z množico pričakovanih vedenj. Razredi, ki takšen vmesnik implementirajo, bodo imela skupno množico vedenj. To pozitivno vpliva na doslednost programske opreme in povečuje konceptualno celoviotst. Zelo koristna je tudi uproaba <strong>načrtovalskih vzorcev</strong> <em>(angl. design patterns)</em>, ki predstavlja pogosto uporabljene strukture razredov za reševanje določenih težav pri načrtovanju in prav tako izboljšajo konceptualno celovitost.</p>
<p>Na konceptualno celovitost vpliva tudi dobro opredeljen načrt in arhitektura, na kateri temelji programska rešitev. Medtem ko je načrt programske opreme ponavadi povezan z notranjo strukturo rešitve, ki se izvaja kot en sam proces, medtem ko arhitekura programske rešitve opisuje, kako programska oprema, ki se izvaja kot več procesov, deluje skupaj in kako so posamezni deli medsebojno povezani.</p>
<p>Poenotenje konceptov pri razvoju programske opreme prav tako poveča konceptualno celovitost. To vključuje sprejemanje različnih konceptov in iskanje skupnega koncepta, tako da je mogoče vsak koncept obravnavati na podoben način. Npr. v operacijskem sistemu Unix je vsak vir dostopen in lahko z njim manipuliramo, kot da bi bil datoteka. Isti nabor operacij je nato mogoče uporabiti na različnih vrstah virov, kar poenostavi sistema, tako da lahko poljuben vir obravnavamo na enak način, s čimer se izognemo izjemam, kar pomaga pri doseganju doslednosti.</p>
<p>Še en način za povečanje konceptualne celovitosti je majhna osrednja skupina, ki sprejme vsako uveljavitev izvorne kode razvijajočega se sistema. To je podobno kot izvajanje pregledov kode, vendar omejuje pregled samo na osrednje člane razvojne skupine. Ti člani so odgovorni, da so vse spremembe skladne z arhitekturo in načrtom programske rešitve. Če je za to odgovoren le posameznik ali manjša skupina, to pomaga pri reševanju načrtovalskih težav in pomaga pri doslednosti.</p>
<p>Konceptualna celovitost je pogosto najpomembnejši dejavnik načrtovanju sistema.</p>
<p>Uveljavljanje konceptualne celovitosti pomaga pri usmerjanju razvojne skupine, tako da sta načrt in logika programske rešitve dosledni in lahko temu sledi vsak član razvojne skupine. Člani skupine tako vedo kako in kje spremeniti programsko opremo, da bo le-ta ustrezala novim zahtevam, zaradi česar je rešitev enostavnejša za vzdrževanje. Konceptualna celovitost se lahko uporabi tudi kot struktura in okvir za poljuben projekt razvoja programske opreme s preprečevanjem neformalne kode, ki lahko vodi do neorganiziranega dela.</p>
</div>
<div id="načela-posploševanja" class="section level3 hasAnchor" number="16.3.5">
<h3><span class="header-section-number">16.3.5</span> Načela posploševanja<a href="P9.html#načela-posploševanja" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>V predhodnjem poglavju <a href="P9.html#stiri-nacrtovalska-nacela">16.2.3</a> smo si ogledali štiri načrtovalska načela, in sicer abstrakcijo <em>(angl. abstraction)</em>, ovijanje <em>(angl. encapsulation)</em>, razgradnja <em>(angl. decomposition)</em> in posploševanje <em>(angl. generalization)</em>. Ta načela pomagajo pri sprejemaju načrtovalskih odločitev objektno usmerjenega razvoja.</p>
<p>Vendar je določene odločitve lažje sprejeti kot druge. Posploševanje in dedovanje sta eni izmed težjih tematik pri objektno usmerjenem načrtovanju in implementaciji.</p>
<p>Dedovanje je zelo zmogljivo načrtovalsko ogrodje, ki lahko pomaga pri izgradnji čistih programskih sistemov z visoko stopnjo ponovne uporabnosti in vzdrževalnosti. Če se načrtovalska načela uporabljajo napačno, lahko povzročijo več težav, kot pa jih rešijo.</p>
<p>Če želimo preveriti, ali smo dedovanja napačno uporabili, je dobro upoštevati nekaj načel posploševanja.</p>
<p>Eno načelo lahko oblikujemo kot vprašanje, kjer se vprašamo, ali je obstoj podrazreda potreben: “Ali uporabljam dedovanje za preprosto skupno rabo atributov ali vedenj, ne da bi dodal kaj posebnega v podrazrede?” Če ima vprašanje pritrdilni odogvor, potem smo dedovanje uporabili napačno, saj ni smisla, da podrazredi v takšnem primeru obstajajo. Samostojen nadrazred bi bil že dovolj.</p>
<p>Npr. <code>Zaposleni</code> je splošna tip za <code>Manager</code>, <code>Prodajalec</code> in <code>Blagajnik</code>, vendar vsak od teh podtipov opravlja posebne funkcije. Dedovanje je v tem primeru smiselno. V primeru, ko pa kreiramo različne vrste pic, pa prave specializacije med različnimi vrstami pic ni, zato so podrazredi nepotrebni.</p>
<p>Druga tehnika je ugotavljanje ali kršimo <strong>načelo zamenjave Liskova</strong> <em>(angl. <a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle"><i class="fa-brands fa-wikipedia-w"></i>Liskov substitution principle</a>)</em>. Omenjeno načelo pravi, da lahko podrazred nadomesti nadrazred, če in samo če podrazred ne spremeni funkcionalnosti nadrazreda. To pomeni, da če podrazred nadomesti nadrazred, vendar nadomesti vedenja nadrazreda z nečim drugačnim, smo dedovanje napačno uporabili.</p>
<p>Npr. če imamo razred kitov, ki vsebuje vedenje plavanja in to nadomestimo z razredom živali, bodo funkcije, kot sta tek in hoja preglasene. Kit se ne bo več obnašal tako, kot bi pričakovali, da se bo obnašal njegov nadrazred, kar krši načelo zamenjave Liskova.</p>
<p>V programskem jeziku Java obstaja knjižnica z razredom <code>Stack</code>, ki je primer napačne rabe dedovanja. Sklad razumemo kot podatkovno strukturo tipa prvi-noter-zadnji-ven z manjšim naborom vedenj, kot je npr. <code>push</code>, <code>pop</code> itd. Ampak razred <code>Stack</code> deduje iz nadrazreda <code>Vector</code>, kar pomeni, da lahko razred <code>Stack</code> vrača element na podanem indeksu in celo vstavi element na določenem indeksu. To niso vedenja, ki se običajno pričakujejo od sklada.</p>
<p>V primerih, ko dedovanje ni primerno, je lahko rešitev razgradnja. Npr. za primer pametnega telefona je bolj primerna razgradnja kot dedovanje. Če se spomnimo primera ločevanja pomislekov v poglavju <a href="P9.html#primer-locevanja-pomislekov">16.3.2.1</a> ima lahko pametni telefon dve funkciji: tradicionalni telefon in fotoaparat.</p>

<div class="figure" style="text-align: center"><span style="display:block;" id="fig:RD-PametniTelefon-drugic"></span>
<img src="https://teaching.lavbic.net/plantuml/svg/RO-x3i8m34LdyXMHM4284GanCF1QGOA9pMrIQfB6bPEM0VXt0kKDctLyxMDxWwu4XaAc5hoNHo5b0gdPCLLEJSaIoqEEGLyviTBSiFPWCHdEfv42CnqQcDWuASx2FvU-LgMtH61mFhQq2q8qnessEYCNpQrUQ6fas7Uw8raJgcYGikSnuojTgfoKmsrDvZEWz2Coez_8-UvQGQ63Tk_AZ0Bj6B8_pZmUYskBXZuRLKaC2KuiUWCrflJc4L-AVbNsJ-F7anS0" alt="Dedovanje na primeru pametnega telefona PlantUML" width="200" />
<p class="caption">
Slika 16.13: Dedovanje na primeru pametnega telefona <a href="https://teaching.lavbic.net/plantuml/uml/RO-x3i8m34LdyXMHM4284GanCF1QGOA9pMrIQfB6bPEM0VXt0kKDctLyxMDxWwu4XaAc5hoNHo5b0gdPCLLEJSaIoqEEGLyviTBSiFPWCHdEfv42CnqQcDWuASx2FvU-LgMtH61mFhQq2q8qnessEYCNpQrUQ6fas7Uw8raJgcYGikSnuojTgfoKmsrDvZEWz2Coez_8-UvQGQ63Tk_AZ0Bj6B8_pZmUYskBXZuRLKaC2KuiUWCrflJc4L-AVbNsJ-F7anS0"><small><i class='fa-solid fa-diagram-project'></i>PlantUML</small></a>
</p>
</div>
<p>V tem primeru ni smiselno uporabiti dedovanja tradicionalnega telefona na pametni telefon ter nato dodati metode fotoaparata v podrazred pametnega telefona, kot prikazuje slika <a href="P9.html#fig:RD-PametniTelefon-drugic#fig:RD-PametniTelefon-drugic">16.13</a>.</p>

<div class="figure" style="text-align: center"><span style="display:block;" id="fig:RD-PametniTelefon-drugic-2"></span>
<img src="https://teaching.lavbic.net/plantuml/svg/TL4zJyCm4DtzAwooyA5sGq8T65eeGWnKWedjwbpQQn9VT7RI0VZlE7MRXBITx7ll-RtpdSl8bY1GQ9E3S_fRQRq2aws5AvlCEMVHkmrvR72M12LYL_UBsSFpFA0Wmhi8hlBmKlqgrvfsLcQly0BM1GgjLoecBg50R-aJSqpPxXiO5xnTi6TeJFnKltR5WJse0tMuXLIo7YK5WosuDxlpiI21xVNDLDTCIGCxIgN1tfCD9vQ-QixwT897mHEV2lwbTTt5m3JKQu7q974JVayVEMNSXwkI1LOqoybbK9FXNaeSqKY_XPDCDwMH1ZS4Mt7Npr9gV46B0eQs65zTOfKQXaogSlBps8tuekzHs5jJku9nLOvl1qjM_P6T4_m1" alt="Razgradnja na primeru pametnega telefona PlantUML" width="420" />
<p class="caption">
Slika 16.14: Razgradnja na primeru pametnega telefona <a href="https://teaching.lavbic.net/plantuml/uml/TL4zJyCm4DtzAwooyA5sGq8T65eeGWnKWedjwbpQQn9VT7RI0VZlE7MRXBITx7ll-RtpdSl8bY1GQ9E3S_fRQRq2aws5AvlCEMVHkmrvR72M12LYL_UBsSFpFA0Wmhi8hlBmKlqgrvfsLcQly0BM1GgjLoecBg50R-aJSqpPxXiO5xnTi6TeJFnKltR5WJse0tMuXLIo7YK5WosuDxlpiI21xVNDLDTCIGCxIgN1tfCD9vQ-QixwT897mHEV2lwbTTt5m3JKQu7q974JVayVEMNSXwkI1LOqoybbK9FXNaeSqKY_XPDCDwMH1ZS4Mt7Npr9gV46B0eQs65zTOfKQXaogSlBps8tuekzHs5jJku9nLOvl1qjM_P6T4_m1"><small><i class='fa-solid fa-diagram-project'></i>PlantUML</small></a>
</p>
</div>
<p>Namesto tega razgradnja pomaga izločiti odgovornosti kamere v njihov lastni razred, kot prikazuje slika <a href="P9.html#fig:RD-PametniTelefon-drugic-2#fig:RD-PametniTelefon-drugic-2">16.14</a>. To omogoča razredu <code>PametniTelefon</code> zagotavljanje odgovornosti fotoaparata in telefona prek ločenih razredov. Razredu <code>PametniTelefon</code> ni treba poznati, kako ti razredi delujejo.</p>
<p>Čeprav je dedovanje močno načelo, je pomembno vedeti, kdaj pravilno uporabiti tehniko ali tvegati vnos še več težav v sistem.</p>
</div>
<div id="preverjanje-modela" class="section level3 hasAnchor" number="16.3.6">
<h3><span class="header-section-number">16.3.6</span> Preverjanje modela<a href="P9.html#preverjanje-modela" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Poleg razumevanja tehnik za načrtovanje sistemov je tudi pomembno poznavanje tehnik za preverjanje sistema. Nekatere od teh tehnik vključujejo testiranje enot <em>(angl. <a href="https://en.wikipedia.org/wiki/Unit_testing"><i class="fa-brands fa-wikipedia-w"></i>unit testing</a>)</em>, beta testiranje <em>(angl. <a href="https://en.wikipedia.org/wiki/Software_release_life_cycle#Beta#Beta"><i class="fa-brands fa-wikipedia-w"></i>beta testing</a>)</em> in simulacije. Druga takšna tehnika je <strong>preverjanje modela</strong> <em>(angl. <a href="https://en.wikipedia.org/wiki/Model_checking"><i class="fa-brands fa-wikipedia-w"></i>model checking</a>)</em>, ki je sistematično preverjanje <strong>modela stanja</strong> <em>(angl. state model)</em> sistema v vseh možnih stanjih. Preverjanje modela pomaga najti napake, ki jih drugi testi ne morejo.</p>
<p>Pri preverjanju modela preverimo vse različna stanja, da poskusimo identificirati morebitne napake s simulacijo različnih dogodkov, ki bi spremenili stanja in spremenljivke sistema. To pomaga razkriti morebitne pomanjkljivosti, tako da ste obveščeni o potencialni kršitvi pravil, ki se pojavljajo v vedenju modela stanja. Preverjanje modela običajno izvaja posebna programska oprema za preverjanje modela. Preverjanje modela se ponavadi izvede med testiranjem programske opreme.</p>
<p>Predstavljajte si programsko opreme, ki ima pravilo, da ne sme povzročiti <strong>zastoja</strong> <em>(angl. deadlock)</em>. Zastoj je situacija, ko sistem ne more nadaljevati, ker dve nalogi čakata na isti vir. Preverjevalnik model bi simuliral različna stanja, ki bi se lahko zgodila v sistemu in če bi bil možen zastoj, bi zagotovil podrobnosti te kršitve.</p>
<p>Sprehodimo se skozi postopek preverjanje model s pomočjo namenskega programa.</p>
<p>Preverjanje modela se začne z generiranje <strong>modela stanja</strong> iz izvorne kode. Model stanja je abstrakten končni avtomat, ki je lahko enem od različnih stanj. Pri preverjanju modela se nato preveri, ali model ustreza določenim vedenjskim lastnostim. Npr. pregleda se lahko za napake, kot so pogoji sočasnosti in razišče vsa možna stanja modela.</p>
<p>Pri preverjanju modela obstajajo tri različne faze.</p>
<p>Prva je <strong>faza modeliranja</strong> <em>(angl. modelling phase)</em>. V tej fazi se vnese opis modela v istih programskih jezikih, kot je sistem. Opisane so tudi morebitne želene lastnosti. V tej fazi se izvedejo tudi <strong>pregledi ustreznosti</strong> <em>(angl. sanity check)</em>, ki so hitra in enostavna preverjanja in izhajajo iz jasne in preproste logike. Koristno je namreč preveriti tudi te enostavne napake, preden uporabite preverjanje modelov, kjer se osredotočite na določene bolj zapletne lastnosti. Preverjanje usterznosti lahko vključuje tudi nekaj tako preprostega, kot je vklop in izklop sistema.</p>
<p>Druga faza je <strong>faza izvajanja</strong> <em>(angl. running phase)</em>, ki se začne z zagonom preverjanja model, da se vidi, kako se model ujema z želenimi lastnostmi, opisanimi v fazi modeliranja.</p>
<p>Tretja in zadnja faza ja <strong>faza analize</strong> <em>(angl. analysis phase)</em>. V tej fazi se preveri, ali so vse želene lastnosti izpolnjene, in ali obstajajo kakršne koli kršitve, ki se imenujejo <strong>protiprimeri</strong> <em>(angl. conterexamples)</em>. Pri preverjanju model moramo pridobiti opise kršitev v sistemu, da lahko analiziramo, kako je do napak prišlo.</p>
<p>Informacije, ki jih zagotovi preverjanje modelo, nam omogočajo pregled programske opreme in odpravo morebitnih težav. Ko so težave odpravljene, je smiselno ponovno pognati preverjanje modela. Ta postopek ponavljamo toliko časa, dokler nismo prepričani, da sistem deluje pravilno, glede na želene lastnosti.</p>
<p>Preverjanje modela pomaga zagotoviti ne samo, da je programska oprema dobro zasnovana, ampak tudi, da ustreza želenim lastnostim in obnašanju ter deluje, kot je predvideno.</p>

</div>
</div>
</div>
<script type="text/javascript">
  $(document).ready(function() {
    
    $("a").click(function(e) {
      if (
        $(this).has(".fa-solid").length == 1 || 
        $(this).has(".fa-brands").length == 1 || 
        $(this).has(".fa-regular").length == 1 || 
        $(this).has("img.git").length == 1
      ) {
        e.preventDefault();
        window.open($(this).attr("href"), '_blank');
      }
    });
  });
</script>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Q6109Y2092"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-Q6109Y2092');
</script>
            </section>

          </div>
        </div>
      </div>
<a href="P8.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="P10.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="assets/lib/gitbook-2.6.7/js/app.min.js"></script>
<script src="assets/lib/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="assets/lib/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="assets/lib/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="assets/lib/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="assets/lib/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="assets/lib/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="assets/lib/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": false,
"twitter": false,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"whatsapp": false,
"all": {}
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 1
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": null,
"search": {
"engine": "fuse",
"options": null
},
"toc": {
"collapse": "section",
"scroll_highlight": true
},
"toolbar": {
"position": "fixed"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
